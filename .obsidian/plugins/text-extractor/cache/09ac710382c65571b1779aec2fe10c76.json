{"path":"System Security/Lecture 12 Security-APIs.pdf","text":"Security APIs System Security (CM0625, CM0631) 2024-25 Università Ca’ Foscari Venezia Riccardo Focardi www.unive.it/data/persone/5590470 secgroup.dais.unive.it Security APIs 2 Hardware Security Modules (HSM) ● Used in the ATM Bank network ● Tamper resistant ● Offer APIs for: ○ Managing cryptographic keys ○ Decrypting/re-encrypting the PIN ○ Checking the validity of the PIN Case study 1: PIN veriﬁcation Photo by Prasun.srivastava - Own work, CC BY-SA 4.0, https://commons.wikimedia.org/w/index.php?curid=34812934 3 PIN veriﬁcation infrastructure (old protocol) 4 PIN veriﬁcation Encrypted PIN Block : contains the PIN at the ATM PIN_V( EPB , vdata,len,dectab,offset ) Data for computing the user PIN Example: PIN_V( {4104,r} k, vdata, 4, 0123456789012345, 4732 ) 1. deck({4104,r} k) = 4104,r 4104 2. encpdk(vdata) = A47295FDE32A48B1 0472 ⊕ 4732 mod 10 = 4104 3. The two values coincide: PIN_V returns ‘true’ 5 PIN V(EPB, vdata, len, dectab, offset) { x1 := dec(k,EPB); // decrypt the typed PIN t_pin:=fcheck(x1); // check format, remove random if (t_pin =⊥) then return(′′format wrong′′); x2 :=encpdk(vdata); // encrypt vdata x3 :=left(len,x2); // take left 4-5 hex digits x4 :=decimalize(dectab,x3); // decimalize digits u_pin := sum_mod10(x4, offset); // sum offset if (t_pin == u_pin) then return(′′PIN is correct′′); } PIN veriﬁcation pseudo-code 6 Decimalization attack [Bond, Zielinski ’03] Example: PIN_V( {4104,r} k, vdata, 4, 0123456789012345, 4732 ) 1. deck({4104,r} k) = 4104,r 4104 2. encpdk(vdata) = A47295FDE32A48B1 0472 ⊕ 4732 mod 10 = 4104 3. PIN_V returns ‘true’ 7 Decimalization attack [Bond, Zielinski ’03] Example: PIN_V( {4104,r} k, vdata, 4, 0 123456789 0 12345, 4732 ) 1. deck({4104,r} k) = 4104,r 4104 2. encpdk(vdata) = A47295FDE32A48B1 0472 ⊕ 4732 mod 10 = 4104 3. PIN_V returns ‘true’ 1. Change one digit of dectab 8 Decimalization attack [Bond, Zielinski ’03] Example: PIN_V( {4104,r} k, vdata, 4, 1 123456789 1 12345, 4732 ) 1. deck({4104,r} k) = 4104,r 4104 2. encpdk(vdata) = A47295FDE32A48B1 0472 ⊕ 4732 mod 10 = 4104 3. PIN_V returns ‘true’ 1. Change one digit of dectab 9 Decimalization attack [Bond, Zielinski ’03] Example: PIN_V( {4104,r} k, vdata, 4, 1 123456789 1 12345, 4732 ) 1. deck({4104,r} k) = 4104,r 4104 2. encpdk(vdata) = A47295FDE32A48B1 0 472 ⊕ 4732 mod 10 = 4104 3. PIN_V returns ‘true’ 1. Change one digit of dectab 2. This propagates ... 10 Decimalization attack [Bond, Zielinski ’03] Example: PIN_V( {4104,r} k, vdata, 4, 1 123456789 1 12345, 4732 ) 1. deck({4104,r} k) = 4104,r 4104 2. encpdk(vdata) = A47295FDE32A48B1 1 472 ⊕ 4732 mod 10 = 4104 3. PIN_V returns ‘true’ 1. Change one digit of dectab 2. This propagates ... 11 Decimalization attack [Bond, Zielinski ’03] Example: PIN_V( {4104,r} k, vdata, 4, 1 123456789 1 12345, 4732 ) 1. deck({4104,r} k) = 4104,r 4104 2. encpdk(vdata) = A47295FDE32A48B1 1 472 ⊕ 4732 mod 10 = 4 104 3. PIN_V returns ‘true’ 1. Change one digit of dectab 2. This propagates ... 12 Decimalization attack [Bond, Zielinski ’03] Example: PIN_V( {4104,r} k, vdata, 4, 1 123456789 1 12345, 4732 ) 1. deck({4104,r} k) = 4104,r 4104 2. encpdk(vdata) = A47295FDE32A48B1 1 472 ⊕ 4732 mod 10 = 5 104 3. PIN_V returns ‘true’ 1. Change one digit of dectab 2. This propagates ... 13 Decimalization attack [Bond, Zielinski ’03] Example: PIN_V( {4104,r} k, vdata, 4, 1 123456789 1 12345, 4732 ) 1. deck({4104,r} k) = 4104,r 4104 2. encpdk(vdata) = A47295FDE32A48B1 1 472 ⊕ 4732 mod 10 = 5 104 3. PIN_V returns ‘true’ 1. Change one digit of dectab 2. This propagates ... 14 Decimalization attack [Bond, Zielinski ’03] Example: PIN_V( {4104,r} k, vdata, 4, 1 123456789 1 12345, 4732 ) 1. deck({4104,r} k) = 4104,r 4104 2. encpdk(vdata) = A47295FDE32A48B1 1 472 ⊕ 4732 mod 10 = 5 104 3. PIN_V returns ‘false’ 1. Change one digit of dectab 2. This propagates … 3. … and eventually changes the result! 15 Decimalization attack [Bond, Zielinski ’03] Example: PIN_V( {4104,r} k, vdata, 4, 1 123456789 1 12345, 4732 ) 1. deck({4104,r} k) = 4104,r 4104 2. encpdk(vdata) = A47295FDE32A48B1 1 472 ⊕ 4732 mod 10 = 5 104 3. PIN_V returns ‘false’ 1. Change one digit of dectab 2. This propagates … 3. … and eventually changes the result! ⇒ We know that 0 appeared in the PIN computation 16 Decimalization attack [Bond, Zielinski ’03] Example: PIN_V( {4104,r} k, vdata, 4, 1 123456789 1 12345, 4 732 ) 1. deck({4104,r} k) = 4104,r 4104 2. encpdk(vdata) = A47295FDE32A48B1 1 472 ⊕ 4732 mod 10 = 5 104 3. PIN_V returns ‘false’ 1. Change one digit of dectab 2. This propagates … 3. … and eventually changes the result! ⇒ We know that 0 appeared in the PIN computation 1. We “compensate” on the offset to ﬁnd the position 17 Decimalization attack [Bond, Zielinski ’03] Example: PIN_V( {4104,r} k, vdata, 4, 1 123456789 1 12345, 3 732 ) 1. deck({4104,r} k) = 4104,r 4104 2. encpdk(vdata) = A47295FDE32A48B1 1 472 ⊕ 4732 mod 10 = 5 104 3. PIN_V returns ‘false’ 1. Change one digit of dectab 2. This propagates … 3. … and eventually changes the result! ⇒ We know that 0 appeared in the PIN computation 1. We “compensate” on the offset to ﬁnd the position 18 Decimalization attack [Bond, Zielinski ’03] Example: PIN_V( {4104,r} k, vdata, 4, 1 123456789 1 12345, 3 732 ) 1. deck({4104,r} k) = 4104,r 4104 2. encpdk(vdata) = A47295FDE32A48B1 1 472 ⊕ 4 732 mod 10 = 5 104 3. PIN_V returns ‘false’ 1. Change one digit of dectab 2. This propagates … 3. … and eventually changes the result! ⇒ We know that 0 appeared in the PIN computation 1. We “compensate” on the offset to ﬁnd the position 19 Decimalization attack [Bond, Zielinski ’03] Example: PIN_V( {4104,r} k, vdata, 4, 1 123456789 1 12345, 3 732 ) 1. deck({4104,r} k) = 4104,r 4104 2. encpdk(vdata) = A47295FDE32A48B1 1 472 ⊕ 3 732 mod 10 = 5 104 3. PIN_V returns ‘false’ 1. Change one digit of dectab 2. This propagates … 3. … and eventually changes the result! ⇒ We know that 0 appeared in the PIN computation 1. We “compensate” on the offset to ﬁnd the position 20 Decimalization attack [Bond, Zielinski ’03] Example: PIN_V( {4104,r} k, vdata, 4, 1 123456789 1 12345, 3 732 ) 1. deck({4104,r} k) = 4104,r 4104 2. encpdk(vdata) = A47295FDE32A48B1 1 472 ⊕ 3 732 mod 10 = 5 104 3. PIN_V returns ‘false’ 1. Change one digit of dectab 2. This propagates … 3. … and eventually changes the result! ⇒ We know that 0 appeared in the PIN computation 1. We “compensate” on the offset to ﬁnd the position 21 Decimalization attack [Bond, Zielinski ’03] Example: PIN_V( {4104,r} k, vdata, 4, 1 123456789 1 12345, 3 732 ) 1. deck({4104,r} k) = 4104,r 4104 2. encpdk(vdata) = A47295FDE32A48B1 1 472 ⊕ 3 732 mod 10 = 4 104 3. PIN_V returns ‘false’ 1. Change one digit of dectab 2. This propagates … 3. … and eventually changes the result! ⇒ We know that 0 appeared in the PIN computation 1. We “compensate” on the offset to ﬁnd the position 2. … and we see if this ﬁxes the result! 22 Decimalization attack [Bond, Zielinski ’03] Example: PIN_V( {4104,r} k, vdata, 4, 1 123456789 1 12345, 3 732 ) 1. deck({4104,r} k) = 4104,r 4104 2. encpdk(vdata) = A47295FDE32A48B1 1 472 ⊕ 3 732 mod 10 = 4 104 3. PIN_V returns ‘true’ 1. Change one digit of dectab 2. This propagates … 3. … and eventually changes the result! ⇒ We know that 0 appeared in the PIN computation 1. We “compensate” on the offset to ﬁnd the position 2. … and we see if this ﬁxes the result! ⇒ If so we discover value and position! 23 This attack has been shown on real devices ● An insider sniffs ATM card data, launches the attack and infers the PIN ● How many invocations on average? ○ Four digit PINs: 14.47 ○ Five digit PINs: 19.3 ○ Strategies found automatically in [Focardi, Luccio ’10] ● Once the PIN is found (old) cards can be cloned ⇒ Thousand of PINs leaked in a lunch break! NOTE: in countries where the chip cards are not yet widely used the attack would still work Decimalization attack [Bond, Zielinski ’03] 24 Case study 2: PKCS#11 25 PKCS#11 is a standard API to cryptographic devices Keys have attributes and are referenced via handles (that we represent with colors) Example: orange key is sensitive and can be used to encrypt/decrypt data PKCS#11 cryptographic operations 26 Security of keys Conﬁdentiality of sensitive keys ● sensitive keys should never be accessible as plaintext outside the device ● all crypto operations happen inside the device Attack scenario 1. the device is used on compromised host 2. the attacker extracts sensitive keys 3. the attacker clones the device 27 Key management example 28 The wrap-and-decrypt attack [CHES’03] 29 Formal veriﬁcation 30 Real attacks [ACM CCS’10] PKCS#11 is still ﬂawed after 20+ years !?! 31 Fixes? Fixes: Various proposals in the literature to modify the API, but never included in PKCS#11 ⇒ Proprietary ﬁxes exist but break compliance Example: oﬄine key management and no key wrapping in production Mitigations: monitor/ﬁlter API calls locally wrap_with_trusted attribute requires that keys are only wrapped under trusted keys (ﬂagged by the Security Oﬃcer) 👍 Secure key wrapping, in principle ⚠ No guidance in the docs ⚠ How should trusted keys be generated/managed? ⚠ What if a trusted key is ﬂagged wrap+decrypt? 32 A new scenario: cloud HSMs HSM hardware accessible as a service in the cloud ● Compliance to standard APIs: no proprietary ﬁxes ● No oﬄine, secure key management procedures ● No API-level monitors/ﬁlters New attacker model: a vulnerability in one application would expose the full (ﬂawed!) PKCS#11 API PKCS#11 33 A formally veriﬁed conﬁguration ● User roles to secure PKCS#11 ● First secure PKCS#11 conﬁguration that does not break the API compliance ● Implementation in a real Cloud HSM solution ● Formal model and automated proof of security Focardi & Luccio ACM CCS’21 34 User roles Normal Users (NU): used in production applications, full API but no attack should be possible Key Managers (KM): create and manage candidate trusted keys Security Oﬃcer (SO): admin, cannot do crypto but marks trusted keys ● KMs and SO only accessed by management apps or humans Full crypto API NU1 … NUk Admin API SO Trusted usersKM1 … KMj 35 Key sharing 1. KMs generate (candidate) trusted wrapping keys 2. KMs share these keys with NUs 3. NUs can use wrapping keys but cannot modify their attributes, e.g., cannot mark them as decrypt keys ● Key sharing is not in PKCS#11 but can be added on top, at the cloud/admin layer KM NU trusted: owned by KM and shared with NU NU can use the key but cannot modify its attributes 36 Secure conﬁguration Rule 1 (Sensitive keys) . Sensitive keys should be generated with wrap_with_trusted set or extractable unset (i.e. will never be wrapped). Rule 2 (Trusted keys) . The SO sets the trusted attribute only on candidate keys generated by one of the KMs. Rule 3 (Roles of candidate keys) . Candidate keys managed by the KMs should only admit wrap and unwrap operations, during their lifetime. Rule 4 (Management of candidate keys) . Candidate keys managed by the KMs should be generated with extractable unset (i.e. will never be wrapped) Rule 5 (Freshness of candidate keys) . Candidate keys managed by the KMs should be freshly generated in the device. 37 AWS CloudHSM implements the required key sharing capability: “Users who share the key can use the key in cryptographic operations, but they cannot change its attributes” ● The secure conﬁguration can be implemented straightforwardly Note: we assume a worst-case scenario in which all keys are shared Implementation in real cloud HSMs Other cloud solutions: ● do not have publicly available documentation (e.g. Utimaco, Microsoft) ● do not implement PKCS#11, yet? (e.g. Google) ● do not seem to implement key sharing in the form we need (e.g. IBM) 38 Formal analysis We formalize a signiﬁcant subset of PKCS#11 in the Tamarin prover: ● Symmetric crypto and wrap ● wrap_with_trusted and trusted attributes ● User roles + key sharing We automatically prove security for an unbounded number of users, keys and sessions rule Wrap: [ !NU(U), !Key(U1,ha1,k1), !Key(U2,ha2,k2) ] --[ Wrap(U,ha1,ha2), IsSet(ha1,'wrap_with_trusted'), IsSet(ha1,'extractable'), IsSet(ha2,'trusted'), IsSet(ha2,'wrap') ]-> [ Out(senc(k1,k2)) ] Normal User U U wraps ha1 with ha2, i.e., k1 with k2 Appropriate attributes ciphertext is sent out (simplified, see the paper for detail!) Keys k1, k2 owned by U1, U2 (ha1, ha2 are handles) 39 Automated proof Keys which, at some point, are marked as trusted are never leaked lemma SecrecyTrusted: \" All W ha k #i #j #w. IsHandle(ha,k)@i & SetAttr(W,ha,'trusted')@j & KU(k)@w ==> F \" Similar lemmas for sensitive keys generated with wrap_with_trusted set or extractable unset (cf. Rule 1) Complete model with additional helper and sanity lemmas available at github.com/secgroup/CloudHSM-model The complete model can be proved automatically in about 1m30s on a MacBook Pro 2018 ha is a handle for key k at time i and ha has trusted set at time j and the attacker knows k at time w implies false, i.e., it cannot occur 40","libVersion":"0.3.2","langs":""}