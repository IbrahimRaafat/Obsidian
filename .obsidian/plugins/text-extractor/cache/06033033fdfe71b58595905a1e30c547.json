{"path":"Advanced Programming/PDFs/5-B. Typed Systems.pdf","text":"ADVANCED PROGRAMMING LANGUAGES Fall 2024, CM 0632. MSc in Computer Science and Informa\u0000on Technology, Ca’ Foscari University of Venice Introducing Types and Typed Systems There is no universal agreement on a common deﬁni\u0000on for the no\u0000on of type. Instead of asking the ques\u0000on What is a type? we may therefore ask why types are needed in programming languages. As note by Luca Cardelli and Peter Wegner in their famous paper, “the road from untyped to typed universes has been followed many \u0000mes in many diﬀerent ﬁelds, and largely for the same reasons”. Consider, for example, the following untyped universes, where untyped means that there is in fact just one class of values: Bit strings in computer memory -expressions in the lambda-calculus Sets in set theory Bit strings in computer memory are the most concrete of these universes, in which the only type (class of values) is the memory word, a bit string of ﬁxed size in terms of which everything is represented, ul\u0000mately: characters, numbers, pointers, structured data, programs, etc. In the (pure) lambda-calculus, as we have discussed, everything is (meant to represent) a func\u0000on. Numbers, data structures and even bit strings can be represented by appropriate func\u0000ons. Yet there is only one type: the type of func\u0000ons from values to values, where all values are themselves func\u0000ons. In set theory, everything is a set, though the structure may vary signiﬁcantly from set to set. To understand how untyped this universe is, one must remember that most of mathema\u0000cs is represented in set theory by sets whose structural complexity reﬂects the complexity of the structures being represented. For example, func\u0000ons are represented by possibly inﬁnite sets of ordered pairs with unique ﬁrst components, while integers are generally represented by sets of sets of sets whose level of nes\u0000ng represents the cardinality of the integer: λ 0 1 2 3 ... = = = = { } {0} {0, 1} {0, 1, 2} ... = = = = ∅ {∅} {∅, {∅}} {∅, {∅} {∅, {∅}}} ... Typed domains As soon as we start working in an untyped universe, types arise naturally. In computer memory, diﬀerent opera\u0000ons presuppose diﬀerent computer memory representa\u0000ons, for characters, integers, strings, . . . In set theory, as we have discussed, dis\u0000nguishing among diﬀerent set orders necessary to avoid paradoxes; In lambda calculus, as shown in our applied version, some func\u0000ons are chosen to represent boolean values, others to represent integers, . . . and so on. Untyped domains decompose thus into subsets with uniform behavior, which we may take as our deﬁni\u0000on of types. A type may be viewed as a set of dressed with clothing (or a suit of armor) that: provides values with a protec\u0000ve covering that hides the values’ underlying representa\u0000on, constrains the way values may be operated with by operators and func\u0000ons. For example, integers are presented as atomic values, thus with a a transparent representa\u0000on (in languages that leave bitwise operators aside . . . ) and exhibit uniform behavior by having the same set of applicable opera\u0000ons, Similarly, func\u0000ons from integers to integers have a protected, internal representa\u0000on and behave uniformly in that they apply to objects of a given type and produce values of a given type. Of course, having deﬁned the intended ways that values of a certain type should be operated upon, we need ways and tools to ensure that those inten\u0000ons are complied with. Type systems provide one such tool, as their main purpose is to impose constraints which prevent objects / expressions from inconsistent interac\u0000on with other objects / expressions. To understand what I mean by “inconsistent interac\u0000on”, have a look at this video! The code snippets shown in the video are (funny and) extreme, but they are conceptually not diﬀerent from situa\u0000ons that arise in the lambda calculus as soon as we move from the untyped domain of the pure lambda calculus to a typed domain, i.e. one in which we are able to dis\u0000nguish between terms whose result will be a numeric value, terms whose result will be a boolean, and terms whose result will be a lambda abstrac\u0000on. In addi\u0000on, we would like to provide such guarantees sta\u0000cally, by just inspec\u0000ng the structure of expressions. The basic components of type systems may be described as follows: 1. Type binding: the mechanism by which we associate a type with each of the basic components of a program, like constants and iden\u0000ﬁers; 2. Typing checking/inference: the process by which each component of the program gets associated with a type, hence checking that operators and func\u0000ons are applied in a type consistent way. Typed Arithme\u0000c Expressions We exemplify the concepts discussed so far and introduce the basic concepts about type systems by looking at a minimal sub-language of boolean and arithme\u0000c expressions. The language and its type system are nearly trivial, but precisely because of their simplicity they prove eﬀec\u0000ve at illustra\u0000ng the techniques and at exemplifying them them at work. Syntax. The expressions of our simple language are deﬁned by the following produc\u0000ons: Note: the legal expressions may be deﬁned equivalently by a system of induc\u0000ve rules for Evalua\u0000on. As we have shown in our previous lecture, all the expressions of this simple language (with the excep\u0000on of the equality test) can be encoded as λ-terms. However, for the purpose of demonstra\u0000ng the import of types and type systems, we build the syntac\u0000c forms from primi\u0000ve constants and operators. Evalua\u0000ng the expressions of the new calculus can be deﬁned as in the lambda calculus, as a syntac\u0000c transforma\u0000on. However, instead of the β-reduc\u0000on used in the λ-calculus, here we introduce a few ad-hoc rules to simplify the arithme\u0000c and boolean operators. The resul\u0000ng reduc\u0000on is s\u0000ll denoted → and deﬁned by the following δ-rules. Numeric Reduc\u0000ons The ﬁrst rule deﬁnes the reduc\u0000on for the numeric redex, i.e. an addi\u0000on whose operands are numeric constant. The two addi\u0000onal rules deﬁne the reduc\u0000on of complex expressions, by reducing the enclosed redexes, from le\u0000 to right. Boolean Reduc\u0000ons a, b, c, ∈ Const M , N , P ∈ Exp ::= ∣ ::= ∣ ∣ ∣ m, n, p true  ∣ false a, b, c M + N M = N if M then N else P numeric literals 0, 1, 2, … boolean literals constants addition equality test conditional M ∈ Exp n + m → n + mN (m and n numeric literals) M + m → M + m′ M → M ′ m + M → m + M ′ M → M ′ a = b → false (a and b different constants) M = M → true M = N → M = N′ M → M ′ N = M → N = M ′ M → M ′ The ra\u0000onale is the same as for the numeric operators. We have four axioms deﬁning the reduc\u0000ons for the corresponding redexes, and one induc\u0000ve rule to reduce a complex expression by reducing the enclosed redex. Values, stuck terms and errors Having introduced the constants and the operators as primi\u0000ves with ad-hoc reduc\u0000on rules brings about a new ques\u0000on related with reduc\u0000on and normal form. In the pure lambda calculus we have deﬁned a normal form as an expression without redexes. In that case, given that all (closed) expressions could be thought of as belonging to the same category, that of func\u0000ons, normal forms are also the natural candidate for a no\u0000on of value. In our present case we could take the same approach and base our deﬁni\u0000on of value of the no\u0000on of normal form, which for the calculus of expressions can be deﬁned as an expression without δ -redex. However, we see immediately there are normal forms that don’t exactly look like values. Take for instance the terms and : they both are normal forms, but they can hardly be considered values. Rather, the very much look like the representa\u0000on of something that went wrong in the computa\u0000on. To dis\u0000nguish normal forms that we may eﬀec\u0000vely classify as values from normal forms that we should take as stuck / error terms we need a reﬁned no\u0000on of value . We make this discussion formal below. Deﬁni\u0000on - Values and Stuck terms. The values of our calculus of arithme\u0000c expressions are dthe numeric and boolean constants. A term that is not a value and that does not contain any redex is a stuck term. Inherent in our interpreta\u0000on of stuck terms as computa\u0000onal errors is the understanding that operators should be applied to their arguments with a certain discipline and that when that disciplined is not complied with we have an error. Now, we would like to be able to tell that its evalua\u0000on will not get stuck without actually evalua\u0000ng a term. To do that, we need to be able to dis\u0000nguish between terms whose result will be a numeric value and terms whose result will be a boolean: that’s the task of the type system. if true then M  else  N → M if false then M  else  N → N if M  then N  else  P → if M  then N  else  P ′ M → M ′ 4 + true if(5 then M else N We introduce two types, and , for classifying terms in this way. The metavariables , etc. will be used throughout the book to range over types. Saying that \"a term has type \" means that we an\u0000cipate - sta\u0000cally - that evaluates to a value of the appropriate form. The Typing Rela\u0000on The typing rela\u0000on is formalized by means of typing judgements of the form (read has type ), and deﬁned induc\u0000vely by the following system of rules: The system is pre\u0000y straigh\u0000orward and mostly self-explanatory. The ﬁrst block of rules (in fact, axioms) assigns the type to the boolean constants and and the type to all the numerals. In the second block, the ﬁrst rule assigns the type to expressions that apply the operator to two expressions, and the type to the equality expression provided that the terms equated are expressions of the same type (either or or, when we get to calculi with more interes\u0000ng sets of types, any other type): the two uses of the single metavariable express the constraint that the the types of the sub-terms and be the same. Finally, the last rule assigns a type to a condi\u0000onal expression based on the types of its subexpressions: the guard must have type , while and must both evaluate to values of the same type. Again, two uses of the metavariable constrain the types of the two branches to coincide. Type Safety: well-typed terms don’t go wrong The fundamental property of type systems is safety (also called soundness), which we summarize with the slogan well-typed terms do not go wrong.. We have already chosen how to formalize what it means for a term to go wrong: it means to reach a stuck term. What we want to know, then, is that well-typed terms do not get stuck. We show this in two steps, commonly known as the progress and preserva\u0000on theorems. Theorem [Progress] If then is a value or there exists such that . Nat Bool S, T , U M T M M M : T M T true : Bool   false : Bool   n : Nat   M + N : Nat M : Nat N : Nat M = N : Bool M : T N : T if M then N else P : T M : Bool N : T P : T Bool true false Nat Nat + Nat Bool Nat Bool T M N M Bool N P T M : T M N M → N Theorem [Preserva\u0000on] If and then . The Progress theorem tells us that well-typed terms are not stuck: either they are values or they can reduce to another term; the Preserva\u0000on theorem, in turn, guarantees that if a well-typed term takes a reduc\u0000on step, then the resul\u0000ng term is also well typed. The combina\u0000on of type preserva\u0000on and progress ensures that all terms whose evalua\u0000on reaches a stuck state a rule out by the type system as ill-typed. No\u0000ce, however, that this does not mean that an ill-typed term will necessarily lead to a stuck state: for instance, is an ill-typed term, but its evalua\u0000on reduces to a value, which is either or . Thus being well-typed cons\u0000tutes a suﬃcient - but not necessary - condi\u0000on for the absence of stuck states during the evalua\u0000on of well-typed terms. That is not surprising indeed, as the set of terms whose evalua\u0000on does not get stuck is a proper subset of terms: given that the la\u0000er is a recursively enumerable set, by Rice’s Theorem, we know that none of its subsets is decidable (hence, there is no way to characterize them with exact precision). The purpose of a sound type system is, therefore, is to enforce — i.e., sa\u0000sfy the type preserva\u0000on and progress theorems — without being too conserva\u0000ve, i.e. it should assign types to most of the programs we actually care about wri\u0000ng. Proofs of the main type system proper\u0000es We conclude the presenta\u0000on by examining its main proper\u0000es. We start with two basic theorems tabout typing deriva\u0000ons. Lemma [Inversion of The Typing Rela\u0000on] If then . If then . If then , and . If then . If then and and . If then and and for some type . Proof: Immediate from an inspec\u0000on of the typing rules. The inversion lemma is some\u0000mes called genera\u0000on lemma for the typing rela\u0000on: given a valid typing statement, it shows how a proof of this statement could have been generated. In fact, the inversion lemma provides us with an algorithm for calcula\u0000ng the types of terms: for each term, the lemma tells us how to calculate its type (if it has one) from the types of its sub-terms. Theorem [Uniqueness of Types] For each term there exists at most one type such that . Moreover, there is just one M : T M → N N : T if true then 0 else false 0 false  true : T  T = Bool  false : T  T = Bool  if M then N else P : T  M : Bool  N : T  P : T  n : T  T = Nat  M + N : T  T = Nat  M : Nat  N : Nat  M = N : T  T = Bool  M : S  N : S S M T M : T deriva\u0000on of the typing judgement from the inference rules. Proof. By induc\u0000on on the set of terms , using the appropriate clause of the inversion lemma (plus the induc\u0000on hypothesis) for each case. We look at the case for condi\u0000onals as a representa\u0000ve, taking . If has no type we are done. Otherwise, if , the inversion lemma tells us that , and . Moreover these types are unique. Then we conclude with an applica\u0000on of the rule for condi\u0000onals. Lemma [Canonical Forms] If is a value and then is either or ; If is a value and then is a numeric literal . Proof. Values can have three forms: , or a numeric literal. Then the proof follows directly from the uniqueness of types. In fact, implies that cannot have type hence it must or , and the same applies dually when . Proof of the Progress Theorem We proceed by induc\u0000on on the deriva\u0000on of the typing judgement . We proceed by cases on all the rules that may have derived the judgement in ques\u0000on, and assume (by rule induc\u0000on) that the theorem holds for the judgements in the premises of the rule. The cases of the axioms for the boolean and integer constants are immediate. since in all these cases is a value. For the other cases, we take rule for condi\u0000onals as a representa\u0000ve: the remaining cases are similar. If derives by the rule for condi\u0000onals, then is of the form , derived from . By the induc\u0000on hypothesis we know that either is a value or else there is some term such that . In the ﬁrst case, by the canonical forms theorem is either or : hence either or . If instead then also , as desired. Proof of the Preserva\u0000on Theorem Wwe proceed by rule induc\u0000on on the judgement , reasoning by cases on the last rule applied in the deriva\u0000on of the judgement. Again we show the case of condi\u0000onals as a representa\u0000ve for the other cases. Assume is the condi\u0000onal expression . Then, the judgement is derived from , and . We have three possible subcases: because and . The proof follows directly from the hypothesis . because and . The proof follows directly from the hypothesis . M M = if then N else PM^ M M : T :M^ bool N : T P : T M M : Bool M true false M M : Nat M n true false M : Bool M Nat true false M : Nat M : T M M : T M if M then N else P : ′ T M : ′ Bool M ′ M ′′ M → ′ M ′′ M ′ true false M → N M → P M → ′ M ′′ M → if M then N else P ′′ M : T M if M then P else Q ′ M : T M : ′ Bool P : T Q : T M → N M = ′ true N = P P : T M → N M = ′ false N = Q Q : T because and . From and , by the induc\u0000on hypothesis we know that . From this and from and , we can apply the rule for condi\u0000onal to derive as desired. Exercises 1. Subject expansion? Having seen the subject reduc\u0000on property, it is reasonable to wonder whether the opposite property -subject expansion-also holds. Is it always the case that, if and then ? If so, prove it. If not, give a counterexample. 2. Typing of condi\u0000onals. As we argued above, the ill-typed terms of our expression language include terms like that actually behaves ﬁne during evalua\u0000on. Show that if we change the typing of condi\u0000onals to make the previous term well-typed we can construct a well-typed term that gets stuck. 3. Typing of equality. In our typing rule for the equality term we require that and have the same type. How would you change the rule to relax that constraint (and admit the equality test on terms of diﬀerent types)? Which of the proper\u0000es of the original system would change with the new rule? In par\u0000cular, would the new system s\u0000ll be sound? If so, prove it. Otherwise provide a counterexample. CREDITS The ﬁrst sec\u0000on of this lecture is taken from Luca Cardelli and Peter Wegner’s paper On understanding types, data abstrac\u0000on, and polymorphism. Compu\u0000ng Surveys, 17(4):471–522, December 1985 The sec\u0000on on arithme\u0000c expressions is adapted from Chapter 8 of Benjamin’s Pierce’s book on Types and Programming Languages. MIT Press. 2001. M → N M → ′ M ′′ N = if M then P else Q ′′ M : ′ Bool M → ′ M ′′ M : ′′ Bool P : T Q : T N : T M → N N : T M : T if true then 0 else false M = N M N","libVersion":"0.3.2","langs":""}