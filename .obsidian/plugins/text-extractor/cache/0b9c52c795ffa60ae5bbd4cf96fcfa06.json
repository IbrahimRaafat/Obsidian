{"path":"Advanced Programming/PDFs/3. Lambda Calculus - Part I.pdf","text":"ADVANCED PROGRAMMING LANGUAGES Fall 2024, CM 0632. MSc in Computer Science and Informa\u0000on Technology, Ca’ Foscari University of Venice The λ Calculus The development of func\u0000onal languages has been inﬂuenced from \u0000me to \u0000me by many sources, but none is as paramount nor as fundamental as the work of Church on the λ calculus. The λ calculus is usually regarded as the ﬁrst func\u0000onal language. Although it was certainly not thought of as programming language at the \u0000me (there weren’t even computers on which to run the programs) modern func\u0000onal languages can be thought of as (nontrivial) embellishments of the λ calculus. Church’s work was mo\u0000vated by the desire to create a calculus – a syntax for terms and set of rewrite rules for transforming terms – to capture the intui\u0000on about the behavior of func\u0000ons. Unlike other approaches, in which func\u0000ons are characterized as sets of (argument, value) pairs , the intent was to capture their computa\u0000onal aspects. The Pure Untyped λ Calculus Syntax. The abstract syntax of the pure untyped λ calculus (a name chosen to dis\u0000nguish it from other versions we will develop later) embodies what are called λ expressions (or terms), deﬁned as follows: A λ abstrac\u0000on is an anonymous func\u0000on with formal parameter . In Scala, this corresponds directly to the func\u0000on literal x = > M . We say that the func\u0000on abstrac\u0000on binds the variable , so that the scope of this bounded variable is , the body of the func\u0000on. No\u0000ce that may have mul\u0000ple occurrences in and all of them are bound by the abstrac\u0000on (unless captured by an inner abstrac\u0000on: see later). On the other hand, the occurrences of a variable not bound are free. Free variables. The free variables of a term are noted , and deﬁned by the following rules, induc\u0000vely on the syntax of expressions: M , N , P ::= ∣ ∣ x, y, z λx.M M N variable abstraction application λx.M x x M x M x M fv(M ) We say that is free in iﬀ . A few addi\u0000onal remarks on λ abstrac\u0000ons. Func\u0000ons and their arguments are in the same syntac\u0000c category, which implies in par\u0000cular that it is possible to use func\u0000ons as func\u0000on arguments (higher-order func\u0000ons). That is, func\u0000ons are ﬁrst-class values. Another noteworthy a\u0000ribute of the λ calculus is its restric\u0000on to func\u0000ons of one argument. There is no real restric\u0000on in that, however, as a func\u0000on of mul\u0000ple argument, say f = ( x , y ) = > M may be represented by the λ expression . and applied as as opposed to . This nota\u0000on has become known as currying, and is said to be a curried func\u0000on. As we will see, the no\u0000on of currying has carried over today as a dis\u0000nguishing syntac\u0000c feature of modern func\u0000onal languages. Indeed, we have the exact same feature in Scala: d e f a d d ( a : I n t , b : I n t ) = a + b / / a d d : ( I n t , I n t ) = > I n t d e f a d d C u r r y ( a : I n t ) = ( b : I n t ) = > a + b / / a d d C u r r y : I n t = > ( I n t = > I n t ) v a l x = a d d ( 3 , 4 ) / / x : I n t v a l f = a d d C u r r y ( 3 ) / / f : I n t = > I n t v a l r = a d d C u r r y ( 3 ) ( 4 ) / / r : I n t By conven\u0000on, func\u0000on applica\u0000on is expressed by juxtaposi\u0000on as opposed to the Scala form M ( N ) , and is le\u0000 associa\u0000ve, so that is the same as . Hence, if in we want to be applied to we have to force it with explicit parentheses: . Func\u0000on applica\u0000on is the core of computa\u0000on in the pure λ calculus, and is formalized in terms of the no\u0000on of subs\u0000tu\u0000on. Subs\u0000tu\u0000on. Subs\u0000tu\u0000on is an intui\u0000vely simple concept, but formalizing it is subtle, as we need to be careful about name clashes. The subs\u0000tu\u0000on of an expression for all the free occurrences of a variable in an expression , wri\u0000en , is deﬁned induc\u0000vely as follows: fv(x) fv(M N ) fv(λx.M ) = = = {x} fv(M ) ∪ fv(N ) fv(M ) − {x} x M x ∈ fv(M ) f ≡ λx.λy.M (f N )P f (N , P ) f M N P (M N )P M N P M N P M (N P ) M x N [M /x]N (s-var) (s-app) (s-abs) [M /x]y [M /x](N P ) [M /x](λy.N ) = ∣ = = ∣ ∣ M y ([M /x]N )([M /x]P ) λy.N λy.[M /x]N λz.([M /x]([z/y]N ) if x = y if x = y if x = y if x = y and y ∈ fv(M )  with z = x, y and z ∈ fv(M ) ∪ fv(N )  The cases (s-var) and (s-app) should be self explained. As to (s-abs) we dis\u0000nguish three sub-cases: the ﬁrst tells us that subs\u0000tu\u0000on only aﬀects the free variables of a term: thus, the subs\u0000tu\u0000on has no eﬀect, as is not free in . in the remaining two cases the side condi\u0000ons are so deﬁned as to make sure no free variable in is captured by the binder of the λ abstrac\u0000on. To guarantee that we further dis\u0000nguish to sub- cases if is not free in we can freely replace each free occurrence of with in the body of the abstrac\u0000on, and be guaranteed against any undesired name clash otherwise we choose another name for (a fresh name that does not appear free in and ) and rename the λ abstrac\u0000on consistently to make sure we have no clashes (and fall back to the previous sub-case) A few examples to illustrate the deﬁni\u0000on at work. , while . Now consider the subs\u0000tu\u0000on : if we disregard the side condi\u0000ons, the resul\u0000ng term would be where has been by the λ abstrac\u0000on, changing (at least intui\u0000vely) the behavior of the term. The problem is resolved by ﬁrst renaming the bound variable , as in and then proceeding with the subs\u0000tu\u0000on: . As we will see shortly, this renaming is sound, as terms that diﬀer only for the renaming the bound variables ( -renaming) may be considered the same term. As a further example we look at the following, more complex case: . To complete the λ calculus, we deﬁne three equality laws on λ expressions: Each of these equa\u0000ons can be jus\u0000ﬁed based on the reading of λ terms as func\u0000ons and by observing that – interpreted as func\u0000ons – the le\u0000-hand and right-hand sides of each equa\u0000on denote the same func\u0000on. In fact: [M /y](λy.N ) y (λy.N ) M y M x M y M N [M /x](λx.x) = λx.x λx.([M /x]x) = λx.M [y/x]λy.(x y) λy.(y y) y captured y λz.(x z) [y/x]λz.(x z) = λz.(y z) α [y/x]((λy.x)(λx.x)x) [y/x]((λy.x)(λx.x)x) = = = = = = [y/x](λy.x)[y/x](λx.x)x) [y/x](λz.x)[y/x](λx.x)x) (λz.y)[y/x](λx.x)x) (λz.y)[y/x](λx.x)([y/x]x) (λz.y)(λx.x)([y/x]x) (λz.y)(λx.x)y by (s-app) by renaming by (s-abs) by (s-app) by (s-abs) by (s-abs) α−conversion (renaming) β−conversion (application) η−conversion (x ∈ fv(M)) λx.M (λx.M )N λx.(M x) = = = λy.[y/x]M [N /x]M M -conversion formalizes the idea that the name of the parameters are irrelevant to the behavior of the func\u0000on -conversion is just parameter passing: it says that applying the func\u0000on of an argument does not change the value computed by the func\u0000on -conversion can be jus\u0000ﬁed by no\u0000ng that the “func\u0000onal behavior” of and of is the same if . Indeed, applying either of the two func\u0000ons to any argument results into the same term, namely . Together with the standard equivalence rules for reﬂexivity, symmetricity, and transi\u0000vity, the three laws induce a theory of equality on the λ calculus, which can be shown to be consistent as a mathema\u0000cal system. In general we say that an equality theory over a domain is consistent if it does not equate values in the domain that are not equal. For instance, and equality theory over the domain of boolean expressions is consistent if it does not equate a true and a false expression. In the calculus, the no\u0000on of consistency is deﬁned in terms of reduc\u0000on and normal form, introduced below. Evalua\u0000on as reduc\u0000on The computa\u0000onal meaning of an expression is deﬁned in terms of rewri\u0000ng, or reduc\u0000on. Reduc\u0000on is the same as conver\u0000bility, but restricted so that -conversion and -conversion and only happens in one direc\u0000on: -reduc\u0000on -reduc\u0000on We write if can be derived by applying a - or an -reduc\u0000on (possibly a\u0000er an - conversion) to or any of 's subexpressions, and we take to be the reﬂexive and transi\u0000ve closure of . I In fact, we will mostly focus on β reduc\u0000on and leave reduc\u0000on on the background, as in the following deﬁni\u0000on. Deﬁni\u0000on - Redex and Normal Form. A redex in an expression is a subexpression of (possibly itself) which can be reduced using reduc\u0000on. An expression is in normal form if it has no redexes. Another way of interpre\u0000ng the reduc\u0000on rela\u0000on is to think of the terms and in as the states of an abstract machine which evaluates by successive reduc\u0000ons un\u0000l it reaches a normal form. Interes\u0000ngly, there exist λ expressions that have no normal form. The paradigma\u0000c case is the following expression with one redex which reduces to itself (thus genera\u0000ng a nontermina\u0000ng reduc\u0000on process): α β η λx.(M x) M x ∈ fv(M) N M N λ β η β (λx.M )N → [N /x]M η λx.(M x) → M     x ∈ f v(M ) M → N N β η α M M →∗ → η M M M β M N M → N M Ω ≡ (λx.(x x))(λx.(x x)) Nevertheless, the normal form provides an a\u0000rac\u0000ve canonical form for a term: it has a clear sense of ﬁnality in a computa\u0000onal sense, and is what we intui\u0000vely think of as the value of an expression. Obviously, we would like for that value to be unique; and we would like to be able to ﬁnd it whenever it exists. The Church-Rosser theorems give us posi\u0000ve results for both of these desires. Church-Rosser Theorem I If , then there exists an expression such that and . In other words, if , then there exists a third term (possibly the same as or ) to which they can both be reduced. Corollary No λ expression can be converted to two dis\u0000nct normal forms (ignoring diﬀerences due to -conversion). Evalua\u0000on order One consequence of the ﬁrst Chuch-Rosser Theorem is that how we arrive at the normal form does not ma\u0000er; in other words, the order of evalua\u0000on is irrelevant, a property that has important consequences for parallel evalua\u0000on strategies. Then , the ques\u0000on arises as to whether or not it is always possible to ﬁnd the normal form (assuming it exists). We begin with a deﬁni\u0000on. Deﬁni\u0000on A normal-order reduc\u0000on is a sequen\u0000al reduc\u0000on in which, whenever there is more than one redex, the le\u0000most, outermost one is chosen ﬁrst. In contrast, an applica\u0000ve-order reduc\u0000on is a sequen\u0000al reduc\u0000on in which the le\u0000most, innermost redex is chosen ﬁrst. Church-Rosser Theorem II If and is in normal form, then there exists a normal-order reduc\u0000on from to . Thus, if a normal form exists, we can always ﬁnd it using normal-order reduc\u0000on. To see why applica\u0000ve-order reduc\u0000on is not always adequate, consider the following example: Applica\u0000ve-order reduc\u0000on Normal order reduc\u0000on We will return to normal- and applica\u0000ve-order reduc\u0000on and the trade-oﬀs between them later on. For now we simply note that the strongest completeness and consistency results have been achieved with M = N P M →∗ P N → ∗P M = N P M N α M →∗ N N M N (λx.y)((λx.xx)(λx.xx)) → → → (λx.y)((λx.xx)(λx.xx)) (λx.y)((λx.xx)(λx.xx)) … (λx.y)((λx.xx)(λx.xx)) → y                                        normal-order reduc\u0000on. Recursion in the λ Calculus One of the cornerstones of the pure λ calculus is its untyped nature: every term denotes a func\u0000on, and func\u0000ons can be applied to any term. As a result, func\u0000on may be applied even to themselves as exempliﬁed in the term! In fact, self-applica\u0000on is at the core of the computa\u0000onal power of the λ calculus. We have already seen the power of this mechanism with the term, capturing the simplest form of inﬁnite computa\u0000on. A further, more interes\u0000ng case for self-applica\u0000on is the following term, known as the combinator: As we show below, the combinator provides the fundamental basis for recursion in the λ Calculus. Fixpoint Theorem Every λ expression has a ﬁxpoint , i.e. a term such that . Proof. Take to be , where is the combinator deﬁned as above. Then we have The theorem implies that any recursive func\u0000on may be wri\u0000en non-recursively, without having to resort to the equa\u0000onal deﬁni\u0000ons we are used to. To see how, consider a recursive func\u0000on deﬁned by: This equa\u0000on essen\u0000ally says that is a ﬁxpoint of the λ expression . But that is exactly what computes for us, so may be deﬁned directly using the combinator as follows: . In fact, from what we just showed: As a concrete example, consider the factorial func\u0000on: Ω Ω Y Y ≡ λf .(λx.f (x x))(λx.f (x x)) Y M N N = (M N ) N (Y M ) Y (Y M ) = = = = λf .(λx.f (x x))(λx.f (x x)) M (λx.M (x x))(λx.M (x x)) M ((λx.M (x x))(λx.M (x x))) M (Y M ) f f = F ...f ... f λf .F ...f ... Y f Y ≡f^ Y (λf .F ...f ...) f^ ≡ = = = Y (λf .F ...f ...) (λf .F ...f ...)(Y (λf .F ...f ...)) (λf .F ...f ...)( )f^ F ... ...f^ (by definition) (by the fixpoint theorem) (by definition) (by β-conversion) v a l fa c t = n = > i f ( n = 0 ) t h e n 1 e l s e ( n * fa c t ( n - 1 ) ) Using the combinator can be wri\u0000en (in a suitable extension of the pure λ calculus to include numerals with their opera\u0000ons, and condi\u0000onals) non-recursively as follows: The ability of the λ calculus to simulate recursion in this way is the key to its power and accounts for its persistence as a useful model of computa\u0000on. The Church-Turing Thesis on computable func\u0000ons The work on λ Calculus was part of a wider eﬀort that in the 1930s was directed to formalize a no\u0000on of computa\u0000on and of computable func\u0000ons. The ﬁrst formaliza\u0000on was proposed in 1933 by Gödel and Herbrand, who deﬁned the class of general recursive func\u0000ons (on natural numbers) as the smallest class of func\u0000ons (with arbitrarily many arguments) closed under composi\u0000on, recursion and minimiza\u0000on and including the zero func\u0000on, the successor operator and all projec\u0000ons. Three years later, in 1936, based on an encoding of the natural numbers (known as Church numerals), Church proposed his own formaliza\u0000on of computable func\u0000ons as the class of func\u0000ons on natural numbers that can be represented as terms of the λ-calculus. In 1936, a further independent model of computa\u0000on was proposed by Turing based on his tape machines (known as Turing Machines) leading to the deﬁni\u0000on of the class of computable func\u0000ons as the class of func\u0000ons (on encoded natural numbers) computable by Turing machines. The three no\u0000ons were soon proved to be equivalent, with the results by Church, Kleene and Turing that showed that the three classes of computable func\u0000ons were in fact the same class: a func\u0000on is λ- computable if and only if it is Turing computable, and if and only if it is general recursive. This quickly led to the widely agreed upon thesis that the concept of computability is accurately characterized by these three equivalent characteriza\u0000ons, a thesis that was later synthesized in what is known as the Church-Turing Thesis, sta\u0000ng that the three formally-deﬁned classes of computable func\u0000ons coincide with the informal no\u0000on of an eﬀec\u0000vely calculable func\u0000on. Exercises Exercise 1 (Variable Bindings). Fully parenthesize each of the following expression based on the standard parsing of λ-calculus expressions, i.e. you should parenthesize applica\u0000ons and λ abstrac\u0000ons. Y fact = Y (λf .λn. if (n = 0) then 1 else (n ∗ f (n − 1))) Then, draw a box around all binding occurrences of variables, underline all usage occurrence of variables, and circle all free variables. For each bound usage occurrence, draw an arrow to indicate its corresponding binding occurrence. λa. z λz. a y (λz. z) λb. b λa. a a λa. λb.(λa. a) λb. a x λx. λx. x (λx. x) Exercise 2 (Alpha equivalence). Which of these three lambda-calculus expressions are alpha equivalent? λx. y λa. a x λx. z λb. b x λa. y λb. b a Exercise 3. (Reduc\u0000on) Put the following expressions into normal form, using β-reduc\u0000on (and α conversion as needed). Remember we’re assuming le\u0000-associa\u0000on (hence, the λ term in the ﬁrst item is the same as ((λz.z) (λq.q q)) (λs.s a)). 1. (λz.z) (λq.q q) (λs.s a) = ((λz.z) (λq.q q)) (λs.s a) 2. (λz.z) (λz.z z) (λz.z q) 3. (λs.λq.s q q) (λa.a) b 4. (λs.λq.s q q) (λq.q) q 5. ((λs.s s) (λq.q)) (λq.q) Exercise 4. (Recursion). Let Y be the recursion operator deﬁned earlier, and let F be a normal-form term.   - exaluate (Y F) using applica\u0000ve order   - evaluate (Y F) using normal order CREDITS Most of the material from this lecture is taken from this paper by Prof. Paul Hudak.","libVersion":"0.3.2","langs":""}