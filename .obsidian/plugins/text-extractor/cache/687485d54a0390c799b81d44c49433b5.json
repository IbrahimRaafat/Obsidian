{"path":"Software Architecture/Lectures/Lecture2_IntroductionToSoftwareArchitect[ure].pdf","text":"News • The schedule has been finalized: – in person lectures always on Thursday at 2pm in Aula B except • Nov. 14th in Lab. 3 • Tuesday Nov. 19th at 8:45 in Aula C – Nov. 28th invited lecture by Unox • https://www.unox.com/us_us/ – Dec. 5th invited lecture by Gianluca Caiazza • Zamperla project • https://www.zamperla.com/ Project • 3 group tasks during the course (two thirds of the grade) – 2 small ones at the beginning – 1 big task at the end implementing the architecture • Topic: hospital management, e.g., – Emergencies – Patient medical records – Schedule of the doctors, exams, … – Hospital ward (https://en.wikipedia.org/wiki/Hospital#Departments_or_wards) – And whatever you might think… An introduction to software architect[ure] [Concepts] Software architectures Pietro Ferrara pietro.ferrara@unive.it Skills • Technical low level knowledge • Technical high level knowledge • System knowledge • Soft skills • Nobody can have all those skills together!!! Technical knowledge • Technical knowledge is extremely wide • Much more stuff you don’t know than you know • Even worse: you ignore even the existence of the most part of technologies • Should you be ashamed? – No!!! – We are all on the same boat Technical debt vs breadth • Developers: depth! – What you know • Architects: breadth! – How much you know • Uncomfortable: the more you learn, the more you don’t know • Depth to implement • Breadth to take decisions – And then delegate implementation • Breadth is more important than depth for an architect Areas of specialization • Don’t completely give up – Important to keep some specific areas of expertise • But be careful about the rest – Your knowledge will become outdated (very) soon – Don’t make decisions with such an outdated knowledge • Architecture evolves very fast – I found only books published after 2020 interesting for this course Software developers career Software developers Software engineers Project managers Software architects CTOs From sw developer to sw architect • A rather standard career promotion – Most of software architects were developers • However, sw architects need to have different skills – Developers spend their time coding • Technical depth – Architects understands business needs, take architectural decisions, manage a team • Technical breadth + soft skills • Good developer does not imply good architect • Hard to find your path to architect… • Some good resources: https://developertoarchitect.com/ Soft skills • Soft skills are needed to be a good software architect – Need to manage a team, interface with customers, etc etc.. • But this course is about software architecture, not soft skills! • But from time to time we’ll discuss things related to soft skills Soft skills, also known as common skills or core skills, are skills applicable to all professions. These include critical thinking, problem solving, public speaking, professional writing, teamwork, digital literacy, leadership, professional attitude, work ethic, career management and intercultural fluency. This is in contrast to hard skills, which are specific to individual professions. https://en.wikipedia.org/wiki/Soft_skills Requirements of IT systems • A requirement of an IT system is either – A service that must be provided • E.g., given two numbers a and b, returns a+b – A characteristic that must be satisfied • E.g., being able to perform 1 million of additions per second • Functional vs non-functional requirements – Architecture is about taking decisions to fulfill (some) non-functional requirements – Functional requirements are completely left out from this course • Topics already covered in standard sw engineering courses – https://moodle.unive.it/course/view.php?id=7859 Architecture characteristics • Textbook: we dislike that term (nonfunctional requirements) because it is self-denigrating. We prefer architecture characteristics • I personally don’t care! • Nonfunctional requirements are widely accepted • Architecture characteristics look fine as well • Let’s stick to the textbook’s choice – But keep in mind that usually they are called nonfunctional requirements • Auditability, performance, security, requirements, scalability, … Criteria Architecture characteristics must meet three main criteria: 1. Specifies a nondomain design consideration – Operational and design criteria for success – How to implement the requirements and why some choices were made 2. Influences some structural aspect of the design – Requires special structural consideration to succeed 3. Is critical or important to application success – Each characteristic adds complexity – Focus only on the ones that are essential A non-exhaustive questionable list follows! Operational architecture characteristics Structural architecture characteristicsCross-cutting architecture characteristics ISO 25010 list of capabilities https://iso25000.com/index.php/en/iso-25000-standards/iso-25010 ✘ Slightly different and overlapping proposals. We will focus on a given (sub)set. Our architecture characteristics Deployability the ease, frequency, and risk of deployment Performance amount of used resources, including time behavior, resource utilization, and capacity Elasticity the ability to handle bursts of users Reliability degree to which a system functions under specified conditions for a specified period of time Evolutionary the ability accept incremental and guided changes Scalability ability for the system to perform and operate as the number of users or requests increases Fault tolerance does the software operate as intended despite hardware or software faults Simplicity the ease of understanding the overall system Modularity degree to which the software is composed of discrete components Testability the ease of and completeness of testing Overall cost “additional” effort required to implement the system Scalability vs Elasticity Scalability Elasticity Which characteristics? • We’d like an IT system that is scalable, reliable, efficient, modular, cheap to implement, etc.. – But we should focus on what it really matters! – (and it is not feasible anyway) • Minimal set of architecture characteristics – With a minimal level of objectives – That are needed for the success of the IT system So far so good… maybe! • The list of architecture characteristics is given – There does not exist a clear description of each one • Even if it’s the list chosen in the textbook! – The boundaries are unclear • Reliability vs fault tolerance? Elasticity vs scalability? – The description is anyway informal • Thus ambiguous • We need to establish some metrics to evaluate them – But this is not possible on a generic description of the architecture – Think about that during the course to make all this more concrete! • When we set up an object we should have that it is: – Specific: target a specific area for improvement. – Measurable: quantify or at least suggest an indicator of progress. – Assignable: specify who will do it. – Realistic: state what results can realistically be achieved, given available resources. – Time-related: specify when the result(s) can be achieved. • https://en.wikipedia.org/wiki/SMART_criteria • We are still missing measurable – And we are going to underspecify it, but we must discuss… SMART objectivesMeasuring architecture characteristics • Architecture characteristics are not physics – There is no absolute way to measure them – Different people will interpret them differently – The target might be different in different systems • E.g., scalable to 1K or 1M or 1B users? • Ideally, automatically assess their achievement – Integrate this in the DevOps lifecycle as tests • For each characteristic we choose, we must define a measure – In an agile way: set a number, iterate the DevOps lifecycle, and then modify it based on the feedback Operational characteristics Elasticity: the ability to handle bursts of users Performance : amount of used resources, including time behavior, resource utilization,... Reliability: degree to which a system functions under specified conditions for a specified period of time Scalability: ability for the system to perform and operate as the number of users or requests increases https://app.wooclap.com/events/SADM/0 questions 8-11 Operational characteristics Elasticity: the ability to handle bursts of users Performance : amount of used resources, including time behavior, resource utilization,... Reliability: degree to which a system functions under specified conditions for a specified period of time Scalability: ability for the system to perform and operate as the number of users or requests increases Elasticity: how much time it takes to handle new computational load, or to scale down when computational load is dropping Performance : how much resources (CPU, RAM, …) are needed per how much computational load Reliability: how many failures the system can accept per amount of time Scalability: if we add more computational resources, can we handle more computational load? Structural characteristics • Deployability: automatically deployed + time required • Fault tolerance: simulation of faults • Simplicity: hard to measure… (see next slide) • Testability: automatic testing + time required + code coverage Deployability : the ease, frequency, and risk of deployment Fault tolerance : does the software operate as intended despite hardware or software faults Simplicity: the ease of understanding the overall system Testability: the ease of and completeness of testing • Module: each of a set of independent units that can be composed to construct a more complex structure – Group of classes in object-oriented programming languages • E.g., packages or modules in Java, namespaces in C# – Group of functions in imperative or functional programming languages • Logical distinction, not necessarily a physical one – Even if modules usually are shipped through artifacts (e.g., jar files) • Modules might depend on each other – But in general we cannot have static cyclic dependendencies Measuring modularity Modularity: degree to which the software is composed of discrete components • Cohesion measures how related the parts are to one another • Many different types: functional, sequential, communicational, procedural, temporal, etc… • Chidamber and Kemerer Object-oriented metrics suite – https://en.wikipedia.org/wiki/Programming_compl exity#Chidamber_and_Kemerer_Metrics – Lack Of Cohesion Metric Measuring modularity Cohesion Modularity: degree to which the software is composed of discrete components High Low Medium ● P: methods not accessing a shared field ● Q: methods sharing a shared field• Coupling: the degree of interdependence between modules • Afferent: the number of incoming connections to a code artifact • Efferent: the number of outgoing connections to other code artifacts Measuring modularity Coupling Modularity: degree to which the software is composed of discrete components Attempting to divide a cohesive module would only result in increased coupling and decreased readability. (Larry Constantine) • Abstractness: measures the amount of abstract elements – Too low: just a main method – Too high: hard to reason • Instability: % efferent coupling – Too high: code breaks more easily when changed • Because it delegates most of the work to other modules Measuring modularity Coupling Modularity: degree to which the software is composed of discrete components #abstract elements (abstract classes, interfaces, …) #concrete elements (non abstract classes) efferent (outgoing) coupling afferent (incoming) coupling • Abstractness and instability always fall between zero and one – In practical contexts… maybe… • More abstract -> more stable • If above the line, uselessness – Too abstract and too instable, impossible to reason on it • If below the line, pain – Too much implementation and not enough abstraction, hard to mantain Measuring modularity Coupling Modularity: degree to which the software is composed of discrete components abstractness instability ideal relationship • Static: source code level coupling – Need to modify the code – Name, type, position, algorithm, … • Dynamic: execution/runtime coupling – Order of execution, timing, values, … Measuring modularity Connascence Modularity: degree to which the software is composed of discrete components Two components are connascent if a change in one would require the other to be modified in order to maintain the overall correctness of the system (Meilir Page-Jones) Measuring modularity Cyclomatic complexity • Measure the structure of the code • Cyclomatic complexity – CC = E - N + 2 • Program as a (control flow) graph – N: number of lines of code • Statements or sequential blocks – E: number of “jumps” • E.g., if statements have two jumps • Questionable anyway but – Provides a clear index – It can be automatically assessed Modularity: degree to which the software is composed of discrete components if(cl<100) return 0; if(c1+c2>500) return 1; return -1; END BEGIN Textbook is different CC = 8 - 7 + 2 = 3 Summing up Characteristic What is needed What it concerns Code Artifact Deployment Speed Robustness Structure Deployability X X Elasticity X X Evolutionary X Fault tolerance X X Modularity X X Overall cost Performance X X Reliability X X X Scalability X X Simplicity X X Testability X X Technologies Source code Artifact Compile and build Server Deploy Katas https://nealford.com/katas/list.html • From where do we start when thinking about an IT system? • Let’s adopt the approach of katas – In martial arts, it is an individual exercise • High-level domain targeted description of an IT system • Next step: derive architecture characteristics from katas • Katas are composed by: – Description: The overall domain problem the system is trying to solve – Users: The expected number and/or types of users of the system – Requirements: Domain/domain-level requirements, as an architect might expect from domain users/domain experts – Additional context First task Implement an IT system that manages hospitals, e.g., – Emergencies, patient medical records, schedule of the doctors, exams, hospital ward, … • Focus on a subsets of (functional and nonfunctional) features – You will need to implement the system at the end! From domain concerns to architecture characteristics • Need to find an agreement with domain stakeholders – But software architects talk a different language • Architecture characteristics mapped to domain concerns? – It is not a one to one relationship • Let’s focus on few domain concerns: – mergers and acquisitions, time to market, user satisfaction, competitive advantage, time and budget • What architecture characteristics we need? – Elasticity, Performance, Reliability, Scalability, Deployability, Fault tolerance, Simplicity, Testability, Modularity Textbook “solution” Explicit characteristics from requirements • Sometimes requirements make explicit the characteristic – E.g., “need to deal with ~10Ks concurrent users” • Consider each single requirement in the kata/specification – Understand what consequences it has on characteristics – Both requirements and users sections are relevant • However, carefully consider what is impacted – E.g., “the IT system is expected to get 100Ks users” • Concurrent users? Always or just in some timeslots (e.g., promotion)? • Elasticity vs scalability • Always discuss with the stakeholders what they want Implicit characteristics • Unfortunately, stakeholders leave many things implicit • E.g., probably nobody will put a requirement on security – But are you willing to get an unsecure IT system at the end? • Another common example is availability – One expects that the system will be available most of the time • But more characteristics lead to more complexity – That lead to higher costs! • Common sense rules – Make explicit all the implicit requirements with the stakeholders – Choose the requirements with the highest priority References • Textbook, Part I – Technical depth/breadth: chapter 2 – Architecture characteristics: chapter 4 – Measuring architecture characteristics: chapter 6 – Measuring modularity: chapter 3 – From requirements to architecture characteristics: chapter 5","libVersion":"0.3.2","langs":""}