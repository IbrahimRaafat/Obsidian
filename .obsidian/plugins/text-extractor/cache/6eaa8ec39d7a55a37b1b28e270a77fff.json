{"path":"Advanced Programming/PDFs/7. Typed Lambda Calculus.pdf","text":"ADVANCED PROGRAMMING LANGUAGES Fall 2024, CM 0632. MSc in Computer Science and Informa\u0000on Technology, Ca’ Foscari University of Venice The Simply Typed Lambda Calculus In our previous lecture, we have introduced a simple sta\u0000c type system for arithme\u0000c expressions. Now we construct a similar type system for the Lambda Calculus: in the interest of brevity, we ignore most of the operators on integers and booleans and focus on the operators from the language of expressions from our last class. In addi\u0000on, we introduce a new primi\u0000ve operator for recursion: Syntax. We start with the following extended syntax, which includes integers and booleans with their operators, condi\u0000onals and a primi\u0000ve version of the combinator. The evalua\u0000on of the operator provides a direct recursion mechanism: As we will see, a primi\u0000ve recursive operator is needed because the combinator from the lambda calculus cannot be typed with the simple types we are going to discuss. Types We start our analysis by introducing the deﬁni\u0000on of types: Typing judgements The typing judgements, of the form , associate the type to the term . The typing context, also known as type environment contains a set of type bindings to qualify the types of the free variables of . While we are generally interested in assigning types to closed expressions, for which the simpler judgement form would suﬃce, the presence of lambda-abstrac\u0000ons requires us to work with type environments as well. Y M , N , P ::= ∣ ∣ ∣ ∣ ∣ ∣ x, y, z λx@ T .M M N n, m, k ∣ M + N true  ∣ false  ∣ M = N if M then N else P fix@ T .M variable abstraction application integers booleans conditional recursion fix fix@ T .M → M ( fix@ T .M ) Y S, T ::= ∣ ∣ Nat Bool S → T natural numbers booleans functions Γ ⊢ M : T T M Γ M M : T In order to assign a type to an abstrac\u0000on , we need to know what type of arguments to expect for the bound variable . There are two possible responses: either we simply annotate the lambda abstrac\u0000on with the intended type of its arguments, or we analyze the body of the abstrac\u0000on to see how the argument is used and try to deduce, from this, what type it should have. We choose the ﬁrst alterna\u0000ve and instead of just , we write where the annota\u0000on on the bound variable tells us to assume that the argument will be of type . In general, languages in which type annota\u0000ons in terms are used to help guide the type-checker are called explicitly typed. Languages in which we ask the type- checker to infer or reconstruct this informa\u0000on are called implicitly typed. Once we know the type of the argument for the abstrac\u0000on, it is clear that the type of the func\u0000on’s result will be just the type of the body , where the occurrences of in are assumed to denote terms of the type assumed for . Accordingly, to establish the rela\u0000on we must be able to show that under the assump\u0000on that , wri\u0000en . Since terms may contain nested -abstrac\u0000ons, we will need, in general, to talk about several such assump\u0000ons. This explains the format of the typing judgement . Formally, a type environment is a sequence of variables and their types, with \" , \" as an operator to extend by adding a new binding on the right. The empty context is some\u0000mes wri\u0000en , but usually we just omit it and write , to state that the (closed) term has type under the empty set of assump\u0000ons. Type environments may also be thought of as ﬁnite maps from variables to their types. Following this intui\u0000on, we write for the set of variables bound by . Typing Rules We are ready to introduce the typing rules. In most type systems, each syntac\u0000c category of the language is associated with a corresponding form of type judgement. In par\u0000cular, a common scenario for standard type systems includes at least two forms of judgement, for expressions and for statements. Given that the Lambda Calculus has just expressions, we only have the judgement form we have discussed, for expressions. Variables. The typing rule for variables also follows immediately from this discussion: a variable has whatever type we are currently assuming it to have. Abstrac\u0000on. The rule for typing abstrac\u0000ons has the general form: where the premise adds one more assump\u0000on to those in the conclusion. To avoid confusion between the new binding for any bindings that may already appear in , we require that the name be chosen so that it is dis\u0000nct from the variables bound by . Since our conven\u0000on is that variables bound by -abstrac\u0000ons λx.M x λx.M λx@ T .M T M x M x λx@ T .M :1 T →1 T 2 M : T 2 x : T 1 x : T ⊢1 M : T 2 λ Γ ⊢ M : T Γ Γ ⊘ ⊢ M : T M T dom( Γ) Γ ( T-Var) Γ ⊢ x : T x : T ∈ Γ ( T-Abs) Γ ⊢ λx@ T .M : T → T 1 1 2 Γ, x : T ⊢ M : T 1 2 x Γ x Γ λ may be renamed whenever convenient, this condi\u0000on can always be sa\u0000sﬁed by renaming the bound variable if necessary. Applica\u0000on. The typing rule for applica\u0000ons is dual to the rule for abstrac\u0000on: If evaluates to a func\u0000on , (under the assump\u0000on that the values represented by its free variables have the types assumed for them in ), and if valuates to a result in , then the result of applying to will be a value of type . Recursion. The typing of recursive terms has the following general form: No\u0000ce that is required to have a func\u0000on type in which the domain and codomain types coincide: that is consistent with the intended behavior of the ﬁxpoint operator and the type preserva\u0000on property we expect of the type system, as reduces to . Constants and operators. The system of inference rules is completed with the direct generaliza\u0000on of the corresponding typing rules for the expression language, adapted to accommodate the context in the judgements so as to account for the presence of variables within the expressions. Proper\u0000es of Typing We proceed as for the language of arithme\u0000c expressions, with a basic lemmas needed in the proof of type safety. Most of these lemmas are similar to what we saw before - we just need to add contexts to the typing rela\u0000on and add clauses to each proof for abstrac\u0000ons, applica\u0000ons, and variables. The only signiﬁcant new result is a subs\u0000tu\u0000on lemma for the typing rela\u0000on Lemma [Inversion of the Typing Rela\u0000on] If , then If then for some such that If then there is some type such that and If , then . ( T-App) Γ ⊢ M N : T Γ ⊢ M : S → T Γ ⊢ N : S M S → T Γ N S M N T ( T-fix) Γ ⊢ fix@ T .M : T Γ ⊢ M : T → T M fix.M M ( fix.M ) Γ Γ ⊢ true : Bool   Γ ⊢ false : Bool   Γ ⊢ n : Nat   Γ ⊢ M + N : Nat Γ ⊢ M : Nat Γ ⊢ N : Nat Γ ⊢ M = N : Bool Γ ⊢ M : T Γ ⊢ N : T Γ ⊢ if M then N else P : T Γ ⊢ M : Bool Γ ⊢ N : T Γ ⊢ P : T Γ ⊢ x : T x : T ∈ Γ Γ ⊢ λx@ S.M : T T = S → U U Γ, x : S ⊢ M : U Γ ⊢ M N : T S Γ ⊢ M : S → T Γ ⊢ N : S Γ ⊢ true : T T = Bool If then . If then , and . If then . If then and and . If then and and for some type . Proof: Immediate from the deﬁni\u0000on of the typing rela\u0000on. Theorem [Uniqueness of Types] For each term and type environment there exists at most one type such that . Moreover, there is just one deriva\u0000on of the typing judgement from the inference rules. Theorem [Canonical Forms] If is a value and then is either or ; If is a value and then is a numeral ; If is a value and then, then is a closed lambda abstrac\u0000on . Theorem [Progress] Suppose is a closed, well-typed term, that is for some . Then either is a value or else there exists such that . Proof. By rule induc\u0000on on the typing judgement . We proceed by cases on all the rules that may have derived the judgement in ques\u0000on, and assume (by rule induc\u0000on) that the theorem holds for the judgements in the premises of the rule. The cases of the axioms for the boolean and integer constants are immediate. since in all these cases is a value. For the other cases, we take the rule for condi\u0000onals as a representa\u0000ve. In this case, is of the form , derived from . By the induc\u0000on hypothesis we know that either is a value or else there is some term such that . In the ﬁrst case, by the canonical forms theorem is either or : hence either or . If instead then also , as desired. To prove the preserva\u0000on theorem, we ﬁrst state a couple of “structural lemmas” that will allow us us to perform some useful manipula\u0000ons of typing deriva\u0000ons. The ﬁrst lemma tells us that we may permute the elements of a context, as convenient, without changing the set of typing statements that can be derived under it. The second says that we can add bindings to the context, again without aﬀec\u0000ng the validity of the judgements being proved. Lemma [Permuta\u0000on] If and is a permuta\u0000on of , then also . Lemma [Weakening] If and , then . Now we can prove a crucial property of the typing rela\u0000on: that the typing rela\u0000ons is preserved when variables are subs\u0000tuted with terms of appropriate types. Γ ⊢ false : T  T = Bool Γ ⊢ if M then N else P : ′ T Γ ⊢ M : Bool  N : T Γ ⊢ P : T Γ ⊢ n : T  T = Nat Γ ⊢ M + N : T  T = Nat Γ ⊢ M : Nat Γ ⊢ N : Nat Γ ⊢ M = N : T  T = Bool Γ ⊢ M : S Γ ⊢ N : S S M Γ T Γ ⊢ M : T v ⊢ v : Bool v true false v ⊢ v: Nat v n v ⊢ v : S → T v λx@ S.M M ⊢ M : T T M N M → N ⊢ M : T M M if M then N else P : ′ T ⊢ M : ′ Bool M ′ M ′′ M → ′ M ′′ M ′ true false M → N M → P M → ′ M ′′ M → if M then N else P : ′′ T Γ ⊢ M : T Γ′ Γ Γ ⊢ ′ M : T Γ ⊢ M : T x ∈ dom( Γ) Γ, x : S ⊢ M : T Lemma [Preserva\u0000on of Types Under Subs\u0000tu\u0000on] If and , then . Proof. By rule induc\u0000on on the judgement , and a case analysis on the ﬁnal rule used in the deriva\u0000on. The most interes\u0000ng cases are the ones for variables and abstrac\u0000ons. Case T-Var. In this case with . There are two sub-cases to consider, depending on whether is or another variable. If , then . Then the desired result is among the assump\u0000ons of the lemma. Otherwise, [N /x]z = z, and the dsired result is immediate. Case T-Abs. The judgement in ques\u0000on is , derived from . By -conversion, we may assume that and . Now: from , using permuta\u0000on we obtain . from using weakening we have . By the induc\u0000on hypothesis, we then have , and then by an applica\u0000on of (T- Abs) we may derive . But this is precisely the result we are looking for, since, by the deﬁni\u0000on of subs\u0000tu\u0000on, given that Theorem [Preserva\u0000on] If and then . Proof. By rule induc\u0000on on the judgement . We show the case of applica\u0000on as a representa\u0000ve for the other cases. Case T-App. is the applica\u0000on term and the judgement in ques\u0000on is of the form , derived from the two premises and . From the hypothesis we isolate three possible subcases. because and . From and , by the induc\u0000on hypothesis we know that . From this, and from by an applicaton of (T-App) we derive as desired. because and . From and , by the induc\u0000on hypothesis we derive . From this and from and . we derive the desired judgement by an applica\u0000on of (T-app) . because and . Then is the conclusion of the (T-Abs) rule with premise . From this judgement, and from , by the subs\u0000tu\u0000on lemma we have , which is just what we wanted to prove. From theory to prac\u0000ce: strong and sta\u0000c typing Just as in the Typed Lambda Calculus, type systems generally accomplish their task by imposing a sta\u0000c type structure on programs which assigns types to all constants, operators, variables, and func\u0000on symbols Γ, x : S ⊢ M : T Γ ⊢ N : S Γ ⊢ [N / x]M : T Γ, x : S ⊢ M : T M = z z : T ∈ ( Γ, x : S) z x z = x [N / x]z = N Γ ⊢ N : S Γ, x : S ⊢ λy@ T .M :1 ′ T →1 T 2 Γ, x : S, y : T ⊢1 M : ′ T 2 α x = y y ∈ fv( N ) Γ, x : S, y : T ⊢1 M : ′ T 2 Γ, y : T , x :1 S ⊢ M : ′ T 2 Γ ⊢ N : S Γ, y : T ⊢1 N : S Γ, y : T ⊢1 [N / x]M : ′ T 2 Γ ⊢ λy@ T [N / x]M :1 ′ T →1 T 2 [N / x]M = λy@ T [N / x]M1 ′ y ∈ fv( N ) Γ ⊢ M : T M → N Γ ⊢ N : T Γ ⊢ M : T M M N ′ ′ Γ ⊢ M N : ′ ′ T Γ ⊢ M : ′ T → ′ T Γ ⊢ N : ′ T ′ M → N M → N M → ′ M ′′ N ≡ M N ′′ ′ Γ ⊢ M : ′ T → ′ T M → ′ M ′′ Γ ⊢ M : ′′ T → ′ T Γ ⊢ N : ′ T ′ Γ ⊢ M N : ′′ ′ T M → N N → ′ N ′′ N ≡ M N ′ ′′ Γ ⊢ N : ′ T ′ N → ′ N ′′ Γ ⊢ N : ′′ T ′ Γ ⊢ M : ′ T → ′ T Γ ⊢ N : ′ T ′ Γ ⊢ M N : ′ ′′ T M → N M = ′ λx@ T .M ′ ′′ N ≡ [N / x]M ′ ′′ Γ ⊢ M : ′ T → ′ T Γ, x : T ⊢ ′ M : ′′ T Γ ⊢ N : ′ T ′ Γ ⊢ [N / x]M : ′ ′′ T deﬁned by the program. Then, the typing rules verify the consistency between deﬁni\u0000on and use, again following the same ra\u0000onale we have discussed for the Typed Lambda Calculus. Sta\u0000c typing is a useful property, but the requirement that all expressions are assigned a type at compile \u0000me turns out to be too restric\u0000ve in certain situa\u0000ons. Indeed, tradi\u0000onal sta\u0000cally typed languages have long suﬀered of a signiﬁcant loss of ﬂexibility, as they excluded programming idioms which, although sound, where incompa\u0000ble with the early binding of program expressions to a speciﬁc type. In modern systems, such as in Scala’s type systems, most of these limita\u0000ons have been overcome thanks to the powerful techniques, developed by the research community, adopted in such systems. For the remaining cases for which sta\u0000c typing is s\u0000ll infeasible, the sta\u0000c checks may be replaced by the weaker requirement that all expressions are guaranteed to be type-consistent by introducing some run- \u0000me type checking. Languages in which all expressions are type-consistent are called strongly typed languages. If a language is strongly typed its compiler can guarantee that the programs it accepts will execute without type errors. In general, we should strive for strong typing, and adopt sta\u0000c typing whenever possible, for at least two good reasons: 1. Robustness: strong, sta\u0000c typing typing allows type inconsistencies to be discovered at compile \u0000me and guarantees that executed programs are type-consistent, hence that no type-related error may arise at run \u0000me. At the same type, strong sta\u0000c typing enforces a programming discipline on the programmer that makes programs more structured and easier to read. 2. Eﬃciency: dynamic checks require run-\u0000me type informa\u0000on on values and therefore take more memory; in addi\u0000on to that, dynamic checks take CPU \u0000me and make the compiled code slower; Having said that, we must remark that types do not always provide all the necessary informa\u0000on to ensure the absence of all errors at run \u0000me, most o\u0000en because some of the proper\u0000es to check are undecidable. Examples of run\u0000me errors escaping strong sta\u0000c typing: 1. a division between two integers (or doubles) may cause a run-\u0000me error, because the denominator may be zero; 2. a method invoca\u0000on o . m with o : T may fail because o is the null reference, even thought the type T provides an m method. 3. an array access a s [ e ] with a s : A r r a y [ T ] and e : I n t may fail at run\u0000me, because may evaluate to an index that does not correspond to any element of a s (the typical “array index out of bounds” excep\u0000on). Of course, in principle, nothing prevents us from reﬁning the no\u0000on of type to achieve more accurate sta\u0000c checks, and thus obtain more robust no\u0000ons of type safety. For example, we could deﬁne types as follows: I n t + = p o s i t i v e i n t e g e r s I n t - = n e g a t i v e i n t e g e r s I n t * = n o n z e r o i n t e g e r s I n t = i n t e g e r and establish the following type for the integer division operator: / : I n t x I n t * = > I n t e The problem, then, is to determine whether a given variable may be assigned one of the reﬁned types. For example, given x : I n t + a n d y : I n t - , what can we say about the type of the expression x + y ? The only correct type to give to x + y would be I n t , so that we could not type-check a division of the form z / ( x + y ) . Similarly, we could say that ﬁeld/method access opera\u0000ons on an object should check not only that the object type is a class deﬁning that ﬁeld/method, but also that the object is not null. Again, the problem is to judge (sta\u0000cally!) whether a given reference is null, which is not feasible in general. Finally, we could make array types more precise by including the array size in the type and then check the array-out-of-bounds error sta\u0000cally, but again that would not be eﬀec\u0000ve in prac\u0000ce. Indeed, modern programming languages take a more pragma\u0000c approach to typing and carry out these checks dynamically, by automa\u0000cally genera\u0000ng code that implements them when a given opera\u0000on is performed. There are, however, interes\u0000ng research proposals to enhance new typing techniques to provide addi\u0000onal power to the sta\u0000c checks. Reﬁnement Types A rather interes\u0000ng example is based on Reﬁnement Types a technique that enables the speciﬁca\u0000on of complex invariants by extending the base type system with reﬁnement predicates drawn from decidable logics. For example, are reﬁnements of the basic type that capture the types I n t * and I n t + introduced above by means of a logical predicate sta\u0000ng that the values being described must be non-nega\u0000ve and posi\u0000ve respec\u0000vely. Based on such deﬁni\u0000ons, we can specify contracts of func\u0000ons by reﬁning func\u0000on types. For example, the following contract states that requires a non-nega\u0000ve dividend and a posi\u0000ve divisor , and ensures that the result is less than the dividend. If a program (reﬁnement) type checks, we can be sure that div will never throw a divide-by-zero excep\u0000on. We will not discuss reﬁnement types further. For more informa\u0000on, please check the following papers: An Introduc\u0000on to Liquid Haskell by Ricardo Peña LiquidHaskell: Experience with Reﬁnement Types in the Real World by Niki Vazou, Eric L. Seidel, Ranjit Jhala (you’ll have to access the link with your Ca’ Foscari account) and / or the following online tutorial: An Introduc\u0000on to LiquidHaskell by Ranjit Jhala, Eric Seidel, and Niki Vazou. type Nat = {v : Int ∣ 0 ≤ v} type Pos = {v : Int ∣ 0 < v} Int v div :: ( n : Nat) → ( d : Pos) → {v : Nat∣v ≤ n} div n d CREDITS The material on the type system proper\u0000es is adapted from Chapter 9 of Prof. Benjamin’s Pierce’s book on Types and Programming Languages. MIT Press. 2001.","libVersion":"0.3.2","langs":""}