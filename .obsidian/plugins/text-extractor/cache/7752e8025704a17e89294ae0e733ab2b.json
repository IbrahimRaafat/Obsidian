{"path":"Advanced Programming/PDFs/1-A. Introduction.pdf","text":"ADVANCED PROGRAMMING LANGUAGES Fall 2024, CM 0632. MSc in Computer Science and Informa\u0000on Technology, Ca’ Foscari University of Venice Introduc\u0000on The course oﬀers an in-depth analysis of the advanced concepts and techniques of modern programming languages together with an introduc\u0000on to the founda\u0000onal tools from programming language theory and type theore\u0000c frameworks available to reason about and asses their design. We will look at the principles underpinning the func\u0000onal, object-oriented and concurrent paradigms, with speciﬁc focus on func\u0000onal languages features and func\u0000onal programming style, and analyze their prac\u0000ce and implementa\u0000on in mainstream programming languages. Most of the development will focus on Scala, but we will draw also from other sta\u0000cally typed languages such as ML, Haskell, Java as well as, occasionally, on dynamically typed languages like python. We start with an overview of the history and evolu\u0000on of programming languages. Programming Language evolu\u0000on The earliest programming languages were developed with one simple goal in mind: to provide a vehicle through which one could control the behavior of computers. Not surprisingly, the early languages reﬂected the structure of the underlying machines fairly well. Although at ﬁrst blush that goal seems eminently reasonable, the viewpoint quickly changed for two very good reasons. ﬁrst it became obvious that what was easy for a machine to compute was not necessarily easy for a human being to reason about. second, as the number of diﬀerent kinds of machines increased, the need arose for a common language with which to program all of them. Thus from primi\u0000ve assembly languages (which were at least a step up from raw machine code) there grew a plethora of high-level programming languages, beginning with FORTRAN in the 1950s. Ques\u0000on: Who knows from which movie is this picture taken? Answer: The new programming languages that followed Fortran and its success are best classiﬁed according to paradigms. These emerged around 1970s-1980s with the advent of languages like C, Simula, Smalltalk, ML and Prolog which marked the rise of the various approaches (the paradigms) to programming: impera\u0000ve, declara\u0000ve (func\u0000onal, logical), object oriented. The development of such paradigms was driven by the desire to ﬁnd appropriate abstrac\u0000ons to express algorithms, encode and manipulate data structures in a principled way, and provide eﬀec\u0000ve (formal) tools to reason about computa\u0000ons and program behavior. The following picture (from h\u0000ps://www.reddit.com/) gives a sense of the extent of the diversity of paradigms and diﬀerent languages created over \u0000me. We will return to paradigms shortly. The point we want to make here is that the quest for adequate abstrac\u0000ons has almost always been driven by the need to respond to the challenges emerging from the technological evolu\u0000on. Technological drivers powering PL evolu\u0000on The case of object-oriented programming (OOP) is par\u0000cularly instruc\u0000ve. In his renown paper , “The free lunch is over” Herb Su\u0000er recalls that even though OOP was introduced back in the 1960s, object- orienta\u0000on didn’t become popular and widely used the 1990s. “when the industry was driven by requirements to write larger and larger systems and OOP’s strengths in abstrac\u0000on and dependency management made it a necessity for achieving large-scale so\u0000ware development that is economical, reliable, and repeatable”. In fact, it was with the development of Graphical User Interfaces (GUIs) that the object-oriented model, long studied in academia, started to spread and becore pervasive in applica\u0000ons and mainstream programming. Similar evolu\u0000onary leaps can be observed in the more recent history of programming languages. Catalysts for change We can iden\u0000fy a number of catalysts that powered signiﬁcant changes in mainstream programming. Internet and the web First of all, the advent of the Internet (and its appeal to the market) shi\u0000ed the programming language goals from eﬃciency to portability and security. This is the scenario where Java came into the arena, with the JVM that brought to the forefront the concept of virtual machine bytecode, already used, e.g., in ML and Smalltalk. But the growth of the web had an impact also on the popularity of other languages: the so-called scrip\u0000ng languages, such as PHP, JavaScript, Python, Ruby, which proved well suited to the development of short programs to be embedded into web pages and web servers. A further reason for the widespread adop\u0000on of such scrip\u0000ng languages is their high-level, declara\u0000ve programming model which enhances produc\u0000vity and fast prototyping and provides a much concise and agile tool with respect to the heavy verbosity and to the picky, some\u0000mes unfriendly discipline imposed by strongly typed languages such as Java or C#. Mul\u0000-core hardware Another landmark in the history of programming languages is concurrent programming, whose catalyst was the emergence of mul\u0000-core hardware calling for more eﬀec\u0000ve use of the available compu\u0000ng power. Moore’s law, according to which CPU performance doubles approximately every two years, is s\u0000ll valid only because performance gains can nowadays be achieved in fundamentally diﬀerent ways: by means of CPU hyperthreading (i.e. many threads in a single CPU) and mul\u0000core (many CPUs on one chip). However, in order to beneﬁt from such a new hardware, applica\u0000ons must be parallel (or concurrent). This has given renewed popularity to func\u0000onal languages such as Haskell, and more recently F# and Scala, which are amenable to parallel execu\u0000on. Side remark: parallel and concurrent compu\u0000ng are diﬀerent concepts, even though they are o\u0000en used as synonyms. They both refer to computa\u0000ons where more than one computa\u0000on thread can make progress at the same \u0000me. However: parallel compu\u0000ng stresses on the fact that many computa\u0000ons are actually carried out simultaneously by means of parallel hardware, such as mul\u0000-core computers or clusters: concurrent computa\u0000on generally refers to tasks that may be executed in parallel either eﬀec\u0000vely, on a parallel hardware, or virtually, by interleaving the execu\u0000on steps of each thread on a sequen\u0000al hardware. Distributed and cloud compu\u0000ng Besides mul\u0000cores and GPUs, which boosted the popularity of concurrent programming, another important achievement of modern technology is cloud compu\u0000ng, which is ac\u0000ng as a catalyst for distributed programming. Distributed systems have long been an established and well studied computa\u0000on model, together with a number of successful programming abstrac\u0000ons like sockets, RPCs (Remote Procedure Call), RMI (Remote Method Invoca\u0000on). However, it is with cloud applica\u0000ons that we have seen the real shi\u0000 from client-server architectures to applica\u0000ons deployed on heterogeneous pla\u0000orms, from mobile devices to cloud-based clusters, running thousands of mul\u0000core processors. Such technological advance requires ad hoc solu\u0000ons to tackle scalability, hardware heterogeneity, fault tolerance, security and privacy eﬀec\u0000vely, but at the same \u0000me demands new programming models with adequate abstrac\u0000ons. The Golang language introduced by Google in 2007 is an example of a new, technology driven programming language design to respond to such needs. Big data Current technological trends are driving new challenges associated with AI and big data. In par\u0000cular, big data applica\u0000ons require high-performance and data-parallel processing at a very high order of magnitude, which in turn need programming abstrac\u0000ons speciﬁcally designed for scale-out computa\u0000ons on supercomputers with massively parallel hardware. A response to this new challenge is the X10 programming language, an open-source language developed at IBM Research, whose design recombines earlier programming abstrac\u0000on into a new mix in order to ﬁt the requirements of High Performance Compu\u0000ng. X10 is designed around the place abstrac\u0000on, which represents a virtual computa\u0000onal node that can be mapped onto a computer node in the cluster, or onto a processor or a core in a supercomputer: a program may then run on a collec\u0000on of places, it can create global data structures spanning mul\u0000ple places, and it can spawn tasks at remote places and detect their termina\u0000on. On a diﬀerent level, the map-reduce model implemented by Google’s MapReduce, Apache Hadoop and Apache Spark provides speciﬁc abstrac\u0000ons to support the logic of big data applica\u0000ons without having to explicitly refer to distribu\u0000on and parallelism, thus ﬁlling the gap between the logic of the applica\u0000on and the execu\u0000on infrastructure is par\u0000cularly large. Interes\u0000ngly, this model is inspired by the map and reduce combinators dis\u0000nc\u0000ve of func\u0000onal programming. CREDITS The material on technological drivers of PL evolu\u0000on is based on [this paper (h\u0000ps://arxiv.org/pdf/1507.07719.pdf) by Silvia Crafa on an Evolu\u0000onary view of programming languages abstrac\u0000ons.","libVersion":"0.3.2","langs":""}