{"path":"Formal Methods/Lectures/lezione10.pdf","text":"FORMAL METHODS FOR SYSTEM VERIFICATION Tackling state space explosion in PEPA models: strong equivalence Sabina Rossi DAIS Universit`a Ca’ Foscari Venezia Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Equivalence between models What is a notion of equivalence? An equivalence between models is a criterion which may be applied to determine whether two models can be considered to be, in some sense, indistinguishable. We are going to study a notion of bisimulation for PEPA models. Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Bisimulation Intuition Two agents are considered to be bisimilar when their externally observed behaviour appears to be the same. This is a formally deﬁned notion of equivalence, based on the labelled transition system underlying the process algebra. These kind of equivalences form the basis of aggregation techniques for reducing the state space of the underlying Markov process, and thus provide a technique for making large models tractable. Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Bisimulation for pure process algebra Informal deﬁnition Bisimulation aims to capture the idea of equivalence as identical observed behaviour. If two agents are bisimilar it is not possible to distinguish between them by observation. We must specify which actions of the agents are considered visible to the observer. In its strongest form bisimilarity means that two agents are capable of exactly the same transitions, and the derivatives which result from the same transitions in the agents are themselves bisimilar. Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Bisimulation for pure process algebra Deﬁnition This notion of equivalence is based on the labelled transition system deﬁned by the semantics of the language. Thus for a language whose labelled transition system is the triple (P, Act, { α −→ | α ∈ Act}) the notion of bisimulation is expressed as follows. Two agents, P, Q ∈ P, are strongly bisimilar, denoted P ∼ Q, if and only if, there is some relation R over P × P such that if (P, Q) ∈ R then for all α ∈ Act: if P α −→ P ′, then for some Q ′, Q α −→ Q ′ and (P ′, Q ′) ∈ R; if Q α −→ Q ′, then for some P ′, P α −→ P ′ and (P ′, Q ′) ∈ R. Thus, if P and Q are strongly bisimilar, any action performed by one must be matched by the other. Moreover, any subsequent action must also be matched. Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Bisimulation for pure process algebra Example 1 When deﬁning a behavioral equivalence of concurrent systems described as LTSs, one might think that it is possible to consider systems equivalent if they give rise to the same (isomorphic) LTSs. Unfortunately, this would lead to unwanted distinctions, e.g., it would consider the two LTSs below diﬀerent. Indeed, their behavior is the same: they can (only) execute inﬁnitely many a-actions, and they should thus be considered equivalent. P0 a Q0 Q1 a a Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Bisimulation for pure process algebra Example 2 Consider the following three systems representing the speciﬁcation of three vending machines that accept two coins and deliver coﬀee or tea. The trace based equivalences equate all of them, the bisimulation based equivalences distinguish all of them. P0 P1 P2 P3 P4 coin1 coin2 coﬀee tea Q0 Q1 Q2 Q3 Q4 Q5 coin1 coin2 coin2 coﬀee tea R0 R1 R2 R3 R4 R5 R6 coin1 coin1 coin2 coin2 coﬀee tea Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Bisimulation for pure process algebra Example 3 Diﬀerently from trace-equivalence, bisimulation is sensitive to deadlocks. P0 P1 P2 P3 a a b Q0 Q1 Q2 a b Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Applications of equivalences between models Entity-to-entity equivalences System-to-model: equivalences are used to establish the conﬁdence in the model as a representation of the system being investigated. Model-to-model: equivalences are used to manipulate or compare models, in order to develop further knowledge about the system, or ﬁnd alternative representations of the system. State-to-state: equivalences are used to simplify the model. When models are large and complex, model simpliﬁcation strategies are required to reduce the complexity of the model. A set of equivalent states can be replaced by one macro-state. In the context of process algebra the concepts of state and model are interchangeable, both being represented as expressions in the language. Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Strong equivalence Intuition In PEPA two components are strongly bisimilar if any a activity of one can be matched by an a activity of the other every a-derivative of one is strongly bisimilar to some a-derivative of the the other the apparent rates of all action types are the same in the two components. Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Conditional transition rate Deﬁnition The notion of strong equivalence is based on the notion of conditional transition rate. The conditional transition rate between two components Pi and Pj via a given action type α, is q(Pi , Pj , α) = ∑ (α,rα)∈Act(Pi |Pj ) rα where Act(Pi |Pj ) = {|(α, rα) ∈ Act(Pi )| Pi (α,rα) −−−−→ Pj |}. This is the rate at which a system behaving as component Pi evolves to behave as component Pj as a result of completing an activity of action type α. It is the sum of activity rates, labelling arcs of type α, connecting the nodes corresponding to Pi and Pj in the derivation graph. Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Total conditional transition rate Deﬁnition Let S be a set of possible derivatives. The total conditional transition rate from Pi to S, denoted q[Pi , S, α] is deﬁned by: q[Pi , S, α] = ∑ Pj ∈S q(Pi , Pj , α). Two PEPA components are strongly equivalent if there is an equivalence relation between them such that, for any action type α, the total conditional transition rates from those components to any equivalence class, via activities of type α are the same. Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Strong equivalence Deﬁnition An equivalence relation R ⊆ C × C is a strong equivalence if whenever (P, Q) ∈ R then for all α ∈ A and for all S ∈ C/R, q[P, S, α] = q[Q, S, α]. The identity relation is a strong equivalence. Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Transitive closure of a union of relations Deﬁnition Let Ri with i ∈ I for some index set I be a family of strong equivlences. The transitive closure of their union, denoted by R = (∪i∈I Ri )∗, is deﬁned as follows. R = limn→∞R n where R 0 = (∪i∈I Ri ) R n = (∪i∈I Ri ); R n−1 with ; denoting the composition of two relations, i.e., (P, Q) ∈ R1; R2 if there exists R such that (P, R) ∈ R1 and (R, Q) ∈ R2. Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION The largest strong equivalence Theorem We are interested in the largest strong equivalence, formed by the union of all strong equivalences. Let Ri with i ∈ I for some index set I be a family of strong equivlences. Then R = (∪i∈I Ri )∗, the transitive closure of their union, is also a strong equivalence. Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Strongly equivalent PEPA components Deﬁnition Two PEPA components P and Q are said to be strongly equivalent, written P ∼= Q, if (P, Q) ∈ R for some strong equivalence R, i.e., ∼= = ∪{R| R is a strong equivalence}. ∼= is the largest strong equivalence. In order to show that P ∼= Q we must ﬁnd a strong equivalence relation R such that (P, Q) ∈ R. Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Strongly equivalent PEPA components Example 4 Consider the following two PEPA models: P0 def = (a, λ).P1 + (a, 2λ).P2 Q0 def = (a, 3λ).Q1 P1 def = (b, β).P3 Q1 def = (b, β).Q2 P2 def = (b, β).P3 Q2 def = (c, γ).Q0 P3 def = (c, γ).P0 P0 P1 P2 P3 (a,2λ)(a,λ) (b,β) (b,β) (c,γ) Q0 Q1 Q2 (a,3λ) (b,β) (c,γ) Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Strongly equivalent PEPA components Example 4 We prove that P0 and Q0 are strongly equivalent. Indeed, consider the reﬂexive, symmetric and transitive closure of the following relation: R = {(P0, Q0), (P1, Q1), (P2, Q1), (P3, Q2)} R induces the following equivalence classes: C1 = {P0, Q0} C2 = {P1, P2, Q1} C3 = {P3, Q2} Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Strongly equivalent PEPA components Example 4: We prove that P0 ∼= Q0. q[P0, C1, x] = q[Q0, C1, x] = 0 for x ∈ {a, b, c} q[P0, C2, x] = q[Q0, C2, x] = 0 for x ∈ {b, c} q[P0, C3, x] = q[Q0, C3, x] = 0 for x ∈ {a, b, c} q[P0, C2, a] = q(P0, P1) + q(P0, P2) = λ + 2λ = 3λ q[Q0, C2, a] = q(Q0, Q1) = 3λ Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Strongly equivalent PEPA components Example 4: We prove that P0 ∼= Q0. q[P1, C1, x] = q[P2, C1, x] = q[Q1, C1, x] = 0 for x ∈ {a, b, c} q[P1, C2, x] = q[P2, C2, x] = q[Q1, C2, x] = 0 for x ∈ {a, b, c} q[P1, C3, x] = q[P2, C3, x] = q[Q1, C3, x] = 0 for x ∈ {a, c} q[P1, C3, b] = q(P1, P3) = β q[P2, C3, b] = q(P2, P3) = β q[Q1, C3, b] = q(Q1, Q2) = β Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Strongly equivalent PEPA components Example 4: We prove that P0 ∼= Q0. q[P3, C1, x] = q[Q2, C1, x] = 0 for x ∈ {a, b} q[P3, C2, x] = q[Q2, C2, x] = 0 for x ∈ {a, b, c} q[P3, C3, x] = q[Q2, C3, x] = 0 for x ∈ {a, b, c} q[P3, C1, c] = q(P3, P0) = γ q[Q2, C1, c] = q(Q2, Q0) = γ Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Properties of strong equivalence Congruence Strong equivalence is a congruence, i.e., it is preserved by all the combinators of the language. Preservation by combinators: if P1 ∼= P2 then a.P1 ∼= a.P2 P1 + Q ∼= P2 + Q P1 \u0003\u0001 L Q ∼= P2 \u0003\u0001 L Q P1/L ∼= P2/L Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Properties of strong equivalence Preservation by recursive deﬁnitions. Let E and F be two PEPA component expressions containing variables ˜X at most. Then E ∼= F if, for all indexed sets of components ˜P, E { ˜P/ ˜X } ∼= F { ˜P/ ˜X }. Replacing a subexpression by a strongly equivalent subexpression, will result in a component expression which is strongly equivalent to the original. Let ˜E and ˜F contain variable ˜X at most. Let ˜A def = ˜E { ˜A/ ˜X }, ˜B def = ˜F { ˜B/ ˜X } and ˜E ∼= ˜F . Then ˜A ∼= ˜B. Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Properties of strong equivalence Equational laws - (Choice) P + Q ∼= Q + P P + (Q + R) ∼= (P + Q) + R Equational laws - (Constant) If A def = P then A ∼= P Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Properties of strong equivalence Equational laws - (Hiding) (P + Q)/L ∼= P/L + Q/L ((α, r ).P)/L ∼= { (τ, r ).P/L if α ∈ L (α, r ).P/L if α ̸∈ L (P/L)/K ∼= P/(L ∪ K ) P/L ∼= P if L ∩ ⃗A(P) = ∅ where ⃗A(P) = ⋃Pi ∈ds(P) A(Pi ) . Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Properties of strong equivalence Equational laws - (Cooperation) P \u0003\u0001 L Q ∼= Q \u0003\u0001 L P P \u0003\u0001 L (Q \u0003\u0001 L R) ∼= (P \u0003\u0001 L Q) \u0003\u0001 L R (P \u0003\u0001 L Q)/K ∼= (P/K ) \u0003\u0001 L (Q/K ) where K ∩ L = ∅ P \u0003\u0001 K Q ∼= P \u0003\u0001 L Q if K ∩ ( ⃗A(P) ∪ ⃗A(Q) ) = L (P \u0003\u0001 L Q) \u0003\u0001 K R ∼= { P \u0003\u0001 L (Q \u0003\u0001 K R) if ⃗A(R) ∩ L \\ K = ∅ ∧ ⃗A(P) ∩ K \\ L = ∅ Q \u0003\u0001 L (P \u0003\u0001 K R) if ⃗A(R) ∩ L \\ K = ∅ ∧ ⃗A(P) ∩ K \\ L = ∅ Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Properties of strong equivalence Equational laws - (Expansion law) Let P ≡ (P1 \u0003\u0001 L P2)/K . Then P ∼= ∑ {(α, r ).(P ′ 1 \u0003\u0001 L P2)/K | P1 (α,r ) −−−→ P ′ 1, α ̸∈ L ∪ K } + ∑ {(α, r ).(P1 \u0003\u0001 L P ′ 2)/K | P2 (α,r ) −−−→ P ′ 2, α ̸∈ L ∪ K } + ∑ {(τ, r ).(P ′ 1 \u0003\u0001 L P2)/K | P1 (α,r ) −−−→ P ′ 1, α ∈ K \\ L} + ∑ {(τ, r ).(P1 \u0003\u0001 L P ′ 2)/K | P2 (α,r ) −−−→ P ′ 2, α ∈ K \\ L} + ∑ {(α, r ).(P ′ 1 \u0003\u0001 L P ′ 2)/K | P1 (α,r1) −−−→ P ′ 1, P2 (α,r2) −−−→ P ′ 2, α ∈ L \\ K , r = r1 rα(P1) r2 rα(P2) min(rα(P1), rα(P2))} + ∑ {(τ, r ).(P ′ 1 \u0003\u0001 L P ′ 2)/K | P1 (α,r1) −−−→ P ′ 1, P2 (α,r2) −−−→ P ′ 2, α ∈ L ∩ K , r = r1 rα(P1) r2 rα(P2) min(rα(P1), rα(P2))} Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Strong equivalence and system components Implications for system components Let SysP and SysQ denote the system components modelled by P and Q, respectively. If P ∼= Q then A(P) = A(Q) rα(P) = rα(Q) for all α ∈ A q(P) = q(Q) Hence SysP and SysQ appear to perform the same actions, at the same rates, and their expected delay before performing some action will be the same. Thus an external observer would be unable to distinguish between them on the basis of a memoryless observation. Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Strong equivalence and the Markov process Implications for the Markov process The relation ∼= restricted to the derivative set of any component P partitions this set. Let ds(P)/ ∼= denote the set of equivalence classes generated in this way. For any component P, ds(P)/ ∼= induces a strong lumpability on the state space of the Markov process corresponding to P. Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Strong equivalence and aggegation Applications of strong equivalence Each equivalence class S ∈ ds(P)/ ∼= represents a set of derivatives which all exhibit the same behaviour. This corresponds to a lumpable partition within the state space of the Markov process. We can thus construct the aggregated Markov chain having a state corresponding to each of the equivalence classes induced on the derivative set by strong equivalence. Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Compositional reasoning Example 5 Consider the following two PEPA models: P0 def = (a, λ).P1 + (a, 2λ).P2 Q0 def = (a, 3λ).Q1 P1 def = (b, β).P3 Q1 def = (b, β).Q2 P2 def = (b, β).P3 Q2 def = (c, γ).Q0 P3 def = (c, γ).P0 R def = (d, δ).(m, µ).R S def = (a, α).P0 + R T def = (a, α).Q0 + R Are S and T strongly equivalent? Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Compositional reasoning Example 5 We have already proved that P0 ∼= Q0. Moreover, (a, α).P0 ∼= (a, α).Q0 (preservation by preﬁx) (a, α).P0 + R ∼= (a, α).Q0 + R (preservation by sum) We can conclude that S ∼= T No extra reasoning on S and T is needed. Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Compositional reasoning Example 6 Consider the following two PEPA models: A def = (P||Q)/L with L = {β, δ} B def = (P/L)||(Q/L) with L = {β, δ} S ′ def = A \u0003\u0001 {α,γ} R S ′′ def = B \u0003\u0001 {α,γ} R Are S and T strongly equivalent? Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Compositional reasoning Example 6 We prove that A ∼= B, i.e., (P||Q)/L ∼= (P/L)||(Q/L). Indeed, (P||Q)/L = (P \u0003\u0001 ∅ Q)/L ∼= (P/L) \u0003\u0001 ∅ (Q/L) since L ∩ ∅ = ∅ ∼= (P/L)||(Q/L) Now, from preservation by cooperation, since A ∼= B we have A \u0003\u0001 {α,γ} R ∼= B \u0003\u0001 {α,γ} R i.e., S ′ ∼= S ′′. Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Compositional reasoning Example 7 Consider the following PEPA model: P def = (α, ⊤).(β, r ).P Q def = (α, s).(γ, t).Q S def = (P||P) \u0003\u0001 {α} Q Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Compositional reasoning Example 7 Draw the derivation graph of S: S0 def = (P||P) \u0003\u0001 {α} Q S1 def = ((β, r ).P||P) \u0003\u0001 {α} (γ, t).Q S2 def = (P||(β, r ).P) \u0003\u0001 {α} (γ, t).Q S3 def = (P||P) \u0003\u0001 α (γ, t).Q S4 def = ((β, r ).P||P) \u0003\u0001 {α} Q S5 def = (P||(β, r ).P) \u0003\u0001 {α} Q S6 def = ((β, r ).P||(β, r ).P) \u0003\u0001 {α} (γ, t).Q S7 def = ((β, r ).P||(β, r ).P) \u0003\u0001 {α} Q Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Compositional reasoning Example 7 The derivation graph of S is: S3 S1 S2 S0 S4 S7 S5 S6 (γ,t) (β,r ) (γ,t) (γ,t) (β,r ) (α,s) (α,s) (α,s) (β,r ) (β,r ) (β,r ) (α,s) (β,r ) (γ,t) (β,r ) (β,r ) Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Compositional reasoning Example 7 Consider the systems: S ′ def = ((P||P) \u0003\u0001 α Q)/{γ} S ′′ def = (P||P) \u0003\u0001 α (Q/{γ}) Are S ′ and S ′′ strongly equivalent? Indeed, S ′ = ((P||P) \u0003\u0001 α Q)/{γ} ∼= ((P||P)/{γ}) \u0003\u0001 α (Q/{γ}) since {α} ∩ {γ} = ∅ ∼= (P||P) \u0003\u0001 α (Q/{γ}) since {γ} ∩ ⃗A(P||P) = ∅ = S ′′. We have proved that S ′ ∼= S ′′. Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Strongly equivalent PEPA components Example 8 Consider the following two PEPA models: C0 def = (α, 2r ).C1 D0 def = (α, 2r ).D1 C1 def = (β, s).C0 D1 def = (β, s).D2 D2 def = (α, r ).D3 + (α, r ).D1 D3 def = (β, s).D0 C0 C1 (α,2r ) (β,s) D0 D1 D3 D2 (α,2r ) (β,s) (β,s) (α,r ) (α,r ) Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Strongly equivalent PEPA components Example 8 We prove that C0 and D0 are strongly equivalent. Indeed, consider the reﬂexive, symmetric and transitive closure of the following relation: R = {(C0, D0), (C0, D2), (C1, D1), (C1, D3)} R induces the following equivalence classes: S1 = {C0, D0, D2} S2 = {C1, D1, D3} Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Strongly equivalent PEPA components Example 8: We prove that C0 ∼= D0. q[C0, S1, x] = q[D0, S1, x] = q[D2, S1, x] = 0 for x ∈ {α, β} q[C0, S2, β] = q[D0, S2, β] = q[D2, S2, β] = 0 q[C0, S2, α] = q(C0, C1, α) = 2r q[D0, S2, α] = q(D0, D1, α) = 2r q[D2, S2, α] = q(D2, D1, α) + q(D2, D3, α) = r + r = 2r q[C1, S2, x] = q[D1, S2, x] = q[D3, S2, x] = 0 for x ∈ {α, β} q[C1, S1, α] = q[D1, S1, α] = q[D3, S1, α] = 0 q[C1, S1, β] = q[D1, S1, β] = q[D3, S1, β] = s Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Strongly equivalent PEPA components Example 8: lumpable partition Let us restrict ∼= to the derivative set of D0, ds(D0). The set ds(D0)/ ∼= contains two equivalence classes: [D0] = {D0, D2} [D1] = {D1, D3} ∼= induces a partition of ds(D0) which is a strong lumpability. The aggegated Markov chain is: [D0] [D1] (α,2r ) (β,s) Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Strong equivalence and lumpability Example 9 Consider a system consisting of the following components: Comp, Res and Repman. Comp is a faulty component which is also capable of completing a task satisfactorily. Res is a resource: the faulty component may need to cooperate with a resource in order to complete its task. Repman represents a repairman: the component also needs to cooperate with a repairman in order to be rapaired. the System consists of two components competing for access to the resource and the repairman. Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Strong equivalence and lumpability Example 9 Consider the following PEPA model for System: Comp def = (error , ϵ).(repair , ρ).Comp + (task, µ).Comp Res def = (task, ⊤).(reset, r ).Res Repman def = (repair , ⊤).Repman System def = ((Comp||Comp) \u0003\u0001 {task} Res) \u0003\u0001 {repair } Repman Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Strong equivalence and lumpability Example 9 Draw the derivation graph of System: S0 def = ((Comp||Comp) \u0003\u0001 {task} Res) \u0003\u0001 {repair } Repman S1 def = ((Comp||Comp) \u0003\u0001 {task} (reset, r ).Res) \u0003\u0001 {repair } Repman S2 def = (((repair , ρ).Comp||Comp) \u0003\u0001 {task} Res) \u0003\u0001 {repair } Repman S3 def = ((Comp||(repair , ρ).Comp) \u0003\u0001 {task} Res) \u0003\u0001 {repair } Repman S4 def = (((repair , ρ).Comp||(repair , ρ).Comp) \u0003\u0001 {task} Res) \u0003\u0001 {repair } Repman S5 def = (((repair , ρ).Comp||Comp) \u0003\u0001 {task} (reset, r ).Res) \u0003\u0001 {repair } Repman S6 def = ((Comp||(repair , ρ).Comp) \u0003\u0001 {task} (reset, r ).Res) \u0003\u0001 {repair } Repman S7 def = (((repair , ρ).Comp||(repair , ρ).Comp) \u0003\u0001 {task} (reset, r ).Res) \u0003\u0001 {repair } Repman Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Strong equivalence and lumpability Example 9 The derivation graph of System is: S3 S6 S4 S0 S1 S7 S2 S5 (task,µ) (error ,ϵ) (repair ,ρ) (reset,r ) (error ,ϵ) (repair ,ρ) (repair ,ρ) (repair ,ρ) (error ,ϵ) (error ,ϵ) (task,µ) (task,µ) (error ,ϵ) (error ,ϵ) (reset,r ) (repair ,ρ) (repair ,ρ) (reset,r ) (task,µ) (repair ,ρ) (error ,ϵ) (reset,r ) (repair ,ρ) (error ,ϵ) Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Strong equivalence and lumpability Example 9 Note that there is a pair of arcs in the derivation graph between the initial state S0 and its one-step derivative S1. This captures the fact that there are two distinct derivations of the activity (task, µ) according to whether the ﬁrst or second component completes the task in cooperation with the resource. The derivation graph is the basis of the underlying CTMC. Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Strong equivalence and lumpability Example 9 The underlying CTMC is: X3 X6 X4 X0 X1 X7 X2 X5 µ ϵ ρ r ϵ ρ ρ ρ ϵ ϵ 2µ ϵ ϵ r ρ ρ r µ ρ ϵ r ρ ϵ Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Strong equivalence and lumpability Example 9 Consider the reﬂexive, symmetric and transitive closure of the following relation: R = {(S2, S3), (S5, S6)} ∪ Id whete Id is the identity relation. R induces the following equivalence classes: [S2] = {S2, S3} [S5] = {S5, S6} [Si ] = {Si } for i ∈ {0, 1, 4, 7} We can prove that R is a strong equivalence. Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Strong equivalence and lumpability Example 9 The aggregated CTMC is: [X4] [X2] [X0] [X1] [X5] [X7] 2ρ µ ϵ ρ 2ϵ 2µ 2ϵ r r ϵ ρ ρ r Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION","libVersion":"0.3.2","langs":""}