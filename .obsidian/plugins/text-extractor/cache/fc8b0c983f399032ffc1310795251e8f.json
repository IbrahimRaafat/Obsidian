{"path":"Formal Methods/Lectures/lezione4.pdf","text":"FORMAL METHODS FOR SYSTEM VERIFICATION Examples: how the language may be used to describe systems Sabina Rossi DAIS Universit`a Ca’ Foscari Venezia Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Example 1: Multiple server queue as a single component Description We consider a queue with c servers a buﬀer with capacity N, where N > c customers arrive at rate λ the service rate of each server is µ S1 Sc λ µ µ µ µ Buﬀer Servers Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Example 1: Multiple server queue as a single component Description When the queue is not full, then the queue will engage in an accept activity at rate λ, representing the acceptance of a customer into the queue. When the queue is full, since the arrival process will not be suspended, the queue will be involved in a loss activity, losing a customer at rate λ. When there are i costumers in the queue, then the queue will engage in a serve activity at rate iµ, if i < c, and at rate cµ when c ≤ i ≤ N. Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Example 1: Multiple server queue as a single component PEPA model Let Qi denote the component representing the behaviour of the queue when there are i costumers present (including those in service). Q0 def = (accept, λ).Q1 ... Qi def = (accept, λ).Qi+1 + (serve, iµ).Qi−1 1 ≤ i < c ... Qj def = (accept, λ).Qj+1 + (serve, cµ).Qj−1 c ≤ j < N ... QN def = (loss, λ).QN + (serve, cµ).QN−1 Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Example 2: Single server queue as two cooperating components Description We consider a single server queue with buﬀer capacity N customer population N customers arrive at rate λ the service rate is µ The arrival process will be suspended when the queue is full as all the costomers will already be present in the queue. µλ Buﬀer Server Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Example 2: Single server queue as two cooperating components PEPA model of the server We represent the queue as two interacting components: Server and Buﬀer . The behaviour of the Server is very simple: whenever it is able, the server will engage in a serve activity at rate µ. Server def = (serve, µ).Server Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Example 2: Single server queue as two cooperating components PEPA model of the buﬀer When the buﬀer is not full customers will arrive at rate λ, so the Buﬀer will engage in an accept activity at rate λ. When the buﬀer is non-empty a customer will be available for service at a rate determined by the server, so the Buﬀer will engage in a serve activity at an unspeciﬁed rate. Buﬀeri will denote the behaviour of the buﬀer when there are i customers in the buﬀer. Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Example 2: Single server queue as two cooperating components PEPA model of the buﬀer Buﬀer0 def = (accept, λ).Buﬀer1 ... Buﬀeri def = (accept, λ).Buﬀeri+1 + (serve, ⊤).Buﬀeri−1 1 ≤ i < N ... BuﬀerN def = (serve, ⊤).BuﬀerN−1 Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Example 2: Single server queue as two cooperating components PEPA model of the queue The Queue is formed by the cooperation of the Buﬀer and the Server for the serve activity. Queue0 def = Buﬀer0 \u0003\u0001 {serve} Server Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Example 3: Simple resource usage as two cooperating components PEPA model We consider a simple system in which a process repeatedly carries out a task. In order to complete its task the process needs access to a resource for part, but not all, of the time. Thus the task can be regarded as being in two stages: the ﬁrst requiring access to the resource the second involving only the process The resource is continuously available except for a short period after it has been used during which it is reset and therefore unavailable. Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Example 3: Simple resource usage as two cooperating components PEPA model The system has two components: Process and Resource. The Process will undertake two activities consecutively: use with some rate r1 in cooperation with the resource, and task at some rate r2. The Resource will engage in two activities consecutively: use at some rate r3 and update at a rate r4. Process def = (use, r1).(task, r2).Process Resource def = (use, r3).(update, r4).Resource System def = Process \u0003\u0001 {use} Resource Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Example 4: Simple resource usage as one component PEPA model We could model the system as a single component. However, this does not reﬂect what is happening in the system as clearly as the previous representation. System′ def = (use, r13).((task, r2).(update, r4).System′ +(update, r4).(task, r2).System′) where r13 = min(r1, r3). Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Example 5: Simple resource usage as several cooperating components PEPA model Representing the components of the system as separate components in the model means that we can easly extend the model to represent a system in which there are two processes, or more, independent of each other but competing for the use of the resource. System′′ def = (Process||Process) \u0003\u0001 {use} Resource Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Example 6: A PC LAN The system Suppose we wish to determine the mean waiting time for data packets at a PC connected to a local area network, operating as a token ring. The transmission medium supports no more than one transmission at any given time. To resolve conﬂicts, a token is passed round the network from one node to another in round robin order. Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Example 6: A PC LAN Token ring communication A node has control of the medium, i.e., it can transmit, only whilst it holds the token. In a PC LAN every PC corresponds to a node on the network. Other nodes on the network might be peripheral devices such as printers or faxes but for the purposes of this study we make no distinction and assume that all nodes are PCs. Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Example 6: A PC LAN Token ring communication: assumption We assume there are currently four PCs (or similar devices) connected to the LAN in a small oﬃce. Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Example 6: A PC LAN Modelling assumptions Each PC can only store one data packet waiting for transmission at a time, so at each visit of the token there is either one packet waiting or no packet waiting. The average rate at which each PC generates data packets for transmission is known to be λ. We also know the mean duration, d = 1/µ, of a data packet transmission, and the mean time, m = 1/ω, taken for the token to pass from one PC to the next. It is assumed that if another data packet is generated, whilst the PC is transmitting, this second data packet must wait for the next visit of the token before it can be transmitted. In other words, each PC can transmit at most one data packet per visit of the token. Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Example 6: A PC LAN Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Example 6: A PC LAN Modelling the system: choosing the components The ﬁrst stage in developing a model of the system in PEPA is to determine the components of the system and the actions which they can undertake. It seems clear that one type of component should be used to represent the PCs. The components representing the four PCs will have essentially the same behaviour. But since token visits the nodes in order we will need to distinguish the components. We will need another component to represent the medium. As remarked previously, the medium can be represented solely by the token. Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Example 6: A PC LAN Modelling the PCs The description of the PCs is very simple. Each PC only has two activities which it can undertake: generate a data packet; transmit a data packet. Moreover we are told that it can only hold one data packet at a time and so these activities must be undertaken sequentially. This suggests the following PEPA component for the ith PC. PCi0 def = (arrive, λ).PCi1 PCi1 def = (transmit, µ).PCi0 This will need some reﬁnement when we consider interaction with the token. Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Example 6: A PC LAN Modelling the token For the token we can think of its current state being characterised by its current position. Thus, if there are N PCs in the network the states of the token correspond to the values {1, 2, . . . , N}. When it is at the ith PC then the token may transmit a data packet if there is one to transmit and then walk on to the next PC or walk on without any transmission if there is no data packet waiting. Tokeni def = (walkoni+1, ω).Tokeni+1+ (transmiti , µ).(walki+1, ω).Tokeni+1 Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Example 6: A PC LAN Reﬁning the components In order to ensure that the token’s choice is made dependent on the state of PC being visited, we add a walkon and a walk action to the PC and impose a cooperation between the PC and the Token for walk, walkon and transmit. PCi0 def = (arrive, λ).PCi1 + (walkoni+1, ω).PCi0 + (walki+1, ω).PCi0 PCi1 def = (transmiti , µ).PCi0 + (walki+1, ω).PCi1 Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Example 6: A PC LAN Complete model: four PC case PC10 def = (arrive, λ).PC11 + (walkon2, ω).PC10 + (walk2, ω).PC10 PC11 def = (transmit1, µ).PC10 + (walk2, ω).PC11 PC20 def = (arrive, λ).PC21 + (walkon3, ω).PC20 + (walk3, ω).PC20 PC21 def = (transmit2, µ).PC20 + (walk3, ω).PC21 PC30 def = (arrive, λ).PC31 + (walkon4, ω).PC30 + (walk4, ω).PC30 PC31 def = (transmit3, µ).PC30 + (walk4, ω).PC31 PC40 def = (arrive, λ).PC41 + (walkon1, ω).PC40 + (walk1, ω).PC40 PC41 def = (transmit4, µ).PC40 + (walk1, ω).PC41 Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Example 6: A PC LAN Complete model: four PC case Token1 def = (walkon2, ω).Token2 + (transmit1, µ).(walk2, ω).Token2 Token2 def = (walkon3, ω).Token3 + (transmit2, µ).(walk3, ω).Token3 Token3 def = (walkon4, ω).Token4 + (transmit3, µ).(walk4, ω).Token4 Token4 def = (walkon1, ω).Token1 + (transmit4, µ).(walk1, ω).Token1 LAN def = (PC10||PC20||PC30||PC40||) \u0003\u0001 L Token1 where L = {walk1, walk2, walk3, walk4, walkon1, walkon2, walkon3, walkon4, transmit1, transmit2, transmit3, transmit4}. Here we have arbitrarily chosen a starting state in which all the PCs are empty and the Token is at PC1. Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Example 6: A PC LAN Transition diagram for PCi PCi0 PCi1 (walk2,ω) (walkon2,ω) (arrive,λ) (transmit,µ) (walk2,ω) Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Example 6: A PC LAN Transition diagram for the Token in a LAN with three PCs Token′ 1 Token1 Token2 Token′ 3 Token′ 2 Token3 (walk2 ,ω) (walkon2 ,ω) (transmit1,µ) (transmit2 ,µ) (walkon3,ω) (walk1,ω) (walk3,ω)(transmit3 ,µ) (walkon1 ,ω) Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION","libVersion":"0.3.2","langs":""}