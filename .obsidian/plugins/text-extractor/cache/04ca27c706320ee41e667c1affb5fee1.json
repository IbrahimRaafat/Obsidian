{"path":"Advanced Programming/PDFs/2. Scala Overview.pdf","text":"ADVANCED PROGRAMMING LANGUAGES Fall 2024, CM 0632. MSc in Computer Science and Informa\u0000on Technology, Ca’ Foscari University of Venice Func\u0000onal programming in Scala Scala was created and developed by Mar\u0000n Odersky at the Ecole Polytechnique Federale de Lausanne (EPFL). It was oﬃcially released for the Java pla\u0000orm in early 2004 and for .Net framework in June 2004. Later on, Scala dropped .Net support in 2012. The name Scala is a combina\u0000on of scalable and language, signifying that it is designed to grow with the demands of its users. Fully interoperable with Java, Scala is a strong, sta\u0000cally typed, general-purpose programming language that integrates object-oriented and func\u0000onal programming within a very elegant framework. The design of Scala is the result of the brilliant engineering of decades of founda\u0000onal research work on programming languages and typing systems that has given birth func\u0000onal languages such ML, Scheme, and Haskell, as well as object-oriented languages such a Smalltalk, F#, and of course Java. Today Scala source can be compiled to Java bytecode and and run on a Java virtual Machine (JVM), on which it provides full interoperability with Java, so that libraries wri\u0000en in either language may be referenced directly in Scala or Java code. Unlike Java, Scala has a clean syntax: since Scala 3, there is also an op\u0000on to use inden\u0000ng (a.k.a. the oﬀ-side rule) to structure block which minimizes the heavy boilerplate code that makes Java overly verbose. Dis\u0000nc\u0000ve of Scala are support for the trademark features of func\u0000onal programming: immutability, higher-order polymorphic func\u0000ons, pa\u0000ern matching, lazy evalua\u0000on; expressive strong, sta\u0000c typing system with rich algebraic data types, parametric types with variance annota\u0000ons, type classes; provision for code reuse mechanisms based on traits and mixins that extend Java’s classes and interfaces rich wealth of libraries, powerful tools and API available to create applica\u0000ons in a wide range target domains. While it provides extensive support for func\u0000onal programming, Scala is not a pure func\u0000onal language, in that it hosts variables, assignment and other side-eﬀec\u0000ng constructs. Having said that, in our ﬁrst overview, below, and throughout the course we will leave the impera\u0000ve features on the background and focus on Scala’s pure subset. REPL A Scala program is a set of value, type and func\u0000on deﬁni\u0000ons, which may grouped into packages. Program execu\u0000on amounts to evalua\u0000ng an expression build out of the deﬁni\u0000ons. The simplest interac\u0000on with Scala is with the interac\u0000ve Interpreter: REPL - Read-Eval-Print-Loop REPL reads defs and expressions, checks and infers types, and if no type error is found executes and prints the result. The type system does not allow casts or other loopholes s c a l a > 1 7 * 3 v a l r e s 0 : I n t = 5 1 Bindings : associate iden\u0000ﬁers to expressions and values s c a l a > v a l x = 1 3 * 2 + 5 v a l x : I n t = 3 1 Note that the type checker discerns the type of the value from its assignment, a process known as type inference. Values deﬁned without a type are not type-less; they are assigned the proper type just as if the type had been included in the deﬁni\u0000on. Although type inference will deduce the correct type to use to store data, it will not override an explicit type that you set. If you deﬁne a value with a type that is incompa\u0000ble with the ini\u0000al value you will get an error: s c a l a > v a l x : I n t = \" H e l l o \" -- [ E 0 0 7 ] T y p e M i s m a t c h E r r o r : ------------------------------------------------- 1 | v a l x : I n t = \" H e l l o \" | ^ ^ ^ ^ ^ ^ ^ | F o u n d : ( \" H e l l o \" : S t r i n g ) | R e q u i r e d : I n t . Iden\u0000ﬁers introduced with a v a l are immutable: they can be assigned data when deﬁned, but can never be reassigned (beware: in REPL, new v a l deﬁni\u0000ons for the same iden\u0000ﬁer hide previous deﬁni\u0000ons. In fact, each new deﬁni\u0000on in REPL opens a new scope) Expression blocks and local bindings. In its pure subset, each piece of Scala code is an expression. Mul\u0000ple expressions can be combined using curly braces ( { and } ) to create a single expression block. An expression has its own scope, and may contain values and variables local to the block: the last expression in the block is the return value for the en\u0000re block. s c a l a > v a l a m o u n t = { v a l x = 5 * 2 0 ; x + 1 0 } v a l a m o u n t : I n t = 1 1 0 The x iden\u0000ﬁer is deﬁned locally to the block: the scope of this deﬁni\u0000on is the block. Expression blocks can span mul\u0000ple lines, and use indenta\u0000on (recommended) instead of curly brackets. s c a l a > v a l a m o u n t = | v a l x = 5 * 2 0 | x + 1 0 v a l a m o u n t : I n t = 1 1 0 Primi\u0000ve types Booleans. true, false, operators (==, &&, ||, !) t r u e , fa l s e : B o o l e a n Integers. 0 , 1 , 2 , -5 , : I n t Strings. \" H e l l o W o r l d \" : S t r i n g Doubles. 1 . 2 , 3 . 1 4 1 5 9 , 2 : D o u b l e There isn’t much else to say about primi\u0000ve types, but one thing is worth men\u0000oning about operators. In Scala all operators are methods. In fact the Scala design is centered around the rather radical choice that, implementa\u0000on-wise, everything is an object. Therefore, unlike Java, where each primi\u0000ve types comes in two versions, boxed vs unboxed, in Scala all primi\u0000ve types are objects, and their operators methods. Luckily, the language supports all the necessary machinery to preserve the familiar look and feel of primi\u0000ve types we are used to. To illustrate, the syntac\u0000c form 2 + 3 is translated into the following method invoca\u0000on before being executed 2 . + ( 3 ) : this syntax (which is perfectly legal Scala Syntax) makes it explicit that what is being executed is the invoca\u0000on of method + on object 2 with parameter 3 . The actual nature of I n t as objects becomes similarly apparent when we explicitly invoke methods as in 2 . t o S t r i n g . Tuples. s c a l a > v a l t r i p l e = ( 4 , 5 , “ G r i ffe n d o r ” ) v a l t r i p l e : ( I n t , I n t , S t r i n g ) = ( 4 , 5 , G r i ffe n d o r ) As we can see, tuples are generated very simply by assembling its elements, which can have diﬀerent types. Tuples can have an arbitrary number of components and each component can be accessed by a corresponding selector: if the tuple has n components, it correspondingly has n selectors noted _ i for all i in the range 1 . . n . Thus: t r i p l e . _ 1 = 4 , t r i p l e . _ 2 = 5 , t r i p l e . _ 3 = G r i ffe n d o r Ques\u0000on: what would you think happens if we try t r i p l e . _ 4 ? Answer: The type checker complains (luckily!) s c a l a > t r i p l e . _ 4 -- [ E 0 0 8 ] N o t F o u n d E r r o r : ----------------------------------------------------- 1 | t r i p l e . _ 4 | ^ ^ ^ ^ ^ ^ ^ ^ ^ | v a l u e _ 4 i s n o t a m e m b e r o f ( I n t , I n t , S t r i n g ) - d i d y o u m e a n t r i p l e . _ 1 ? 1 e r r o r fo u n d LISTS Lists are predeﬁned in Scala, and can be constructed very conveniently with the L i s t constructor: s c a l a > v a l l i s t o ft h r e e = L i s t ( 1 , 2 , 3 ) l i s t O fT h r e e : L i s t [ I n t ] = L i s t ( 1 , 2 , 3 ) The actual constructors are : : (cons, right associa\u0000ve) and N i l so that L i s t ( 1 , 2 , 3 ) is short for 1 : : 2 : : 3 : : N i l . Lists have two main selectors L i s t . h e a d and L i s t . t a i l and a very rich set of operators. What it is What it does List() or Nil The empty List List(“Cool”, “tools”, “rule”) Creates a new List[String] with the three values “Cool”, “tools”, and “rule” val thrill = “Will” :: “ﬁll” :: “un\u0000l” :: Nil Creates a new List[String] with the three values “Will”, “ﬁll”, and “un\u0000l” List(“a”, “b”) ::: List(“c”, “d”) Concatenates two lists (returns a new List[String] with values “a”, “b”, “c”, and “d”) thrill(2) Returns the element at index 2 (zero based) of the thrill list (returns “un\u0000l”) thrill.count(s => s.length == 4) Counts the number of string elements in thrill that have length 4 (returns 2) thrill.drop(2) Returns the thrill list without its ﬁrst 2 elements (returns List(“un\u0000l”)) thrill.dropRight(2) Returns the thrill list without its rightmost 2 elements (returns List(“Will”)) thrill.exists(s => s == “un\u0000l”) Determines whether a string element exists in thrill that has the value “un\u0000l” (returns true) thrill.ﬁlter(s => s.length == 4) Returns a list of all elements, in order, of the thrill list that have length 4 (returns List(“Will”, “ﬁll”)) thrill.forall(s => s.endsWith(“l”)) Indicates whether all elements in the thrill list end with the le\u0000er “l” (returns true) thrill.foreach(print) Executes the print statement on each of the strings in the thrill list (prints “Willﬁllun\u0000l”) thrill.head Returns the ﬁrst element in the thrill list (returns “Will”) thrill.init Returns a list of all but the last element in the thrill list (returns List(“Will”, “ﬁll”)) thrill.isEmpty Indicates whether the thrill list is empty (returns false) thrill.last Returns the last element in the thrill list (returns “un\u0000l”) thrill.length Returns the number of elements in the thrill list (returns 3) What it is What it does thrill.map(s => s + “y”) Returns a list resul\u0000ng from adding a “y” to each string element in the thrill list (returns List(“Willy”, “ﬁlly”, “un\u0000ly”)) thrill.mkString(\", \") Makes a string with the elements of the list (returns “Will, ﬁll, un\u0000l”) thrill.remove(s => s.length == 4) Returns a list of all elements, in order, of the thrill list except those that have length 4 (returns List(“un\u0000l”)) thrill.reverse Returns a list containing all elements of the thrill list in reverse order (returns List(“un\u0000l”, “ﬁll”, “Will”)) Like tuples, lists are immutable in Scala. Unlike tuples, lists elements must all have the same type. Beware of subtyping, however! s c a l a > v a l m l = L i s t ( 1 , \" a a a \" , L i s t ( 1 , ' c ' ) , 2 . 3 ) v a l m l : L i s t [ M a t c h a b l e ] = L i s t ( 1 , a a a , L i s t ( 1 , c ) , 2 . 3 ) Condi\u0000onal Expressions Assume x and y are two I n t values. The following expression calculates the maximum between them s c a l a > v a l m a x = i f ( x > y ) x e l s e y m a x : I n t = 2 0 Both branches of the condi\u0000onal must have the same type, which is the type of the condi\u0000onal expression. Condi\u0000onals may span more than one line, in which case expression blocks for the two branches may be used to improve readability. Condi\u0000onals may also come without the e l s e branch, in which case the return type is U n i t , the type of no values that the impure fragment of Scala employs to account for statements. Match Expressions In their simplest form m a t c h expressions are akin to C’s and Java’s “switch” statements, where a single input item is evaluated and the ﬁrst pa\u0000ern that is “matched” is executed and its value returned. Like C’s and Java’s “switch” statements, Scala’s match expressions support a default or wildcard “catch-all” pa\u0000ern. Unlike them, only zero or one pa\u0000ern can match; there is no “fall-through” from one pa\u0000ern to the next one in line, nor is there a “break” statement that would prevent this fall- through. The tradi\u0000onal “switch” statement is limited to matching by value, but Scala’s match expressions are an amazingly ﬂexible device that also enables matching such diverse items as types, regular expressions, numeric ranges, and data structure contents. Here we look at the basic uses of match expressions: we’ll return to them when discussing algebraic data types. Here’s a deﬁni\u0000on of m a x using match instead of condi\u0000onal expressions: v a l m a x = x > y m a t c h | c a s e t r u e = > x | c a s e fa l s e = > y Here’s a code snipped tes\u0000ng the s t a t u s value returned by a server in response to a service request: v a l m e s s a g e = s t a t u s m a t c h | c a s e 2 0 0 = > | \" o k \" | c a s e 4 0 0 = > | \" E R R O R - w e c a l l e d t h e s e r v i c e i n c o r r e c t l y \" | c a s e 5 0 0 = > | \" E R R O R - t h e s e r v i c e e n c o u n t e r e d a n e r r o r \" Expression Loops (a.k.a. for comprehensions) A loop expression is a term for exercising a task repeatedly, itera\u0000ng over a range of data execu\u0000ng an expression every \u0000me and return a collec\u0000on of all the expression’s return values. Scala for-loops are highly customizable, suppor\u0000ng nested itera\u0000ng, ﬁltering, and value binding. We illustrate for loops at work with R a n g e s created using the t o operator. s c a l a > fo r ( x < - 1 t o 7 ) y i e l d \" D a y \" + + x . t o S t r i n g v a l r e s 0 : I n d e x e d S e q [ S t r i n g ] = V e c t o r ( D a y 1 , D a y 2 , D a y 3 , D a y 4 , D a y 5 , D a y 6 , D a y 7 ) Note that the result has type I n d e x e d S e q [ S t r i n g ] , an indexed sequence of S t r i n g , and is assigned a V e c t o r , one of the implementa\u0000ons of I n d e x e d S e q . Because of Scala’s support for subtyping, a V e c t o r (a subtype of I n d e x e d S e q ) can be assigned to an I n d e x e d S e q -typed value. For loops may be used with ﬁltering guards: s c a l a > v a l t h r e e s = fo r ( i < - 1 t o 2 0 i f i % 3 = = 0 ) y i e l d i t h r e e s : I n d e x e d S e q [ I n t ] = V e c t o r ( 3 , 6 , 9 , 1 2 , 1 5 , 1 8 ) Func\u0000ons At its most basics, a Scala func\u0000on is a named wrapper for an expression. Here is an example of deﬁning and invoking input-less func\u0000ons: s c a l a > d e f h i : S t r i n g = \" h i \" h i : S t r i n g s c a l a > h i r e s 0 : S t r i n g = \" h i \" As with values, the return type of func\u0000ons may be inferred, but just as like values func\u0000ons are easier to read with explicit types. More interes\u0000ngly than the previous example, func\u0000ons can take parameters: s c a l a > d e f m a x ( x : I n t , y : I n t ) : I n t = i f ( x > y ) t h e n x e l s e y d e f m a x ( x : I n t , y : I n t ) : I n t Recursive and tail recursive func\u0000ons Recursive func\u0000ons are func\u0000ons that invoke themselves, typically with some type of parameter or external condi\u0000on that will be checked to avoid an inﬁnite loop of func\u0000on invoca\u0000on. Here’s an example of a recursive func\u0000on that raises an integer by a given posi\u0000ve exponent: s c a l a > d e f p o w e r ( x : I n t , n : I n t ) : I n t = | i f ( n > = 1 ) x * p o w e r ( x , n -1 ) | e l s e 1 p o w e r : ( x : I n t , n : I n t ) : I n t Recursive func\u0000ons are elegant, but o\u0000en ineﬃcient, as their execu\u0000on uses stack space (and may in fact cause the dreaded “Stack Overﬂow” error, where invoking a recursive func\u0000on too many \u0000mes eventually using up all of the available stack space). To prevent that, the Scala compiler can op\u0000mize recursive func\u0000ons with tail recursion, a technique that can be ac\u0000vated when the recursive call is the last expression to be evaluated in the func\u0000on body, and hence may reuse the exis\u0000ng func\u0000on stack space. Only func\u0000ons whose last expression is the recursive invoca\u0000on can be op\u0000mized for tail-recursion: in, instead, the result of invoking itself is used for anything but the direct return value, a func\u0000on can’t be op\u0000mized. To mark a func\u0000on as intended for tail-recursion, Scala provides the annota\u0000on @ a n n o t a t i o n . t a i l r e c before the func\u0000on deﬁni\u0000on or on the previous line. Here’s the same example again only marked with the t a i l r e c annota\u0000on, to let Scala know we expect it to be op\u0000mized for tail-recursion: if it cannot be, the compiler should treat it as an error: s c a l a > @ a n n o t a t i o n . t a i l r e c d e f p o w e r ( x : I n t , n : I n t ) : I n t = i f ( n > = 1 ) x * p o w e r ( x , n -1 ) e l s e 1 -- E r r o r : ---------------------------------------------------------------------- 3 | i f ( n > = 1 ) x * p o w e r ( x , n -1 ) e l s e 1 | ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ | C a n n o t r e w r i t e r e c u r s i v e c a l l : i t i s n o t i n t a i l p o s i t i o n Uh, the func\u0000on couldn’t be op\u0000mized because the recursive call is not the last statement in the func\u0000on. This is understandable. Let’s try to switch the “if” and “else” condi\u0000ons and try again: s c a l a > @ a n n o t a t i o n . t a i l r e c d e f p o w e r ( x : I n t , n : I n t ) : I n t = i f ( n < 1 ) 1 e l s e x * p o w e r ( x , n -1 ) -- E r r o r : ---------------------------------------------------------------------- 3 | i f ( n < 1 ) 1 e l s e x * p o w e r ( x , n -1 ) | ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ | C a n n o t r e w r i t e r e c u r s i v e c a l l : i t i s n o t i n t a i l p o s i t i o Same problem: now the recursive call looks like it’s the last expression, but if we consider how the expression is evaluated we see that we are taking the result of the recursive call and then mul\u0000plying it by a value, so that the last opera\u0000on is the mul\u0000plica\u0000on, not the recursive call. The standard way to ﬁx this is to move the mul\u0000plica\u0000on into the invoked func\u0000on instead of mul\u0000plying its result: that’s the familiar tail recursion technique based on accumulators. s c a l a > d e f p o w e r ( x : I n t , n : I n t ) : I n t = @ a n n o t a t i o n . t a i l r e c d e f t r _ p o w e r ( x : I n t , n : I n t , a c c : I n t ) : I n t = i f ( n > = 1 ) t r _ p o w e r ( x , n -1 , a c c * x ) e l s e a c c t r _ p o w e r ( x , n , 1 ) Higher Order Func\u0000ons All the func\u0000ons discussed so far have been introduced with the d e f keyword. But func\u0000ons are ordinary values in Scala, hence they can be bound to iden\u0000ﬁers - and similarly, stored in data structures or passed as arguments to other func\u0000ons - as any other value. We start with a simple example: s c a l a > v a l a b s : ( I n t = > I n t ) = ( n : I n t ) = > i f ( n < 0 ) t h e n -n e l s e n v a l a b s : I n t = > I n t = L a m b d a $ 1 3 4 3 / 1 4 6 0 3 4 6 9 6 7 @ 7 c d 3 e 0 d a Here I n t = > I n t is the type of func\u0000ons that, when applied to an integer value return an integer (or raise and excep\u0000on, but we’ll ignore that, for the \u0000me being). The body of the deﬁni\u0000on: ( n : I n t ) = > i f ( n < 0 ) t h e n -n e l s e n is a func\u0000on literal, i.e. an expression that represents the func\u0000on mapping its argument to the corresponding absolute value. Binding func\u0000ons to names is not very surprising. A more interes\u0000ng, and paradigma\u0000c, prac\u0000ce in func\u0000onal programming is the case of higher-order func\u0000ons, i.e. func\u0000ons that accept other func\u0000ons as arguments, a mechanism that provides a very powerful form of abstrac\u0000on in program design. Later on along the course, we will see how eﬀec\u0000ve this mechanism is, and how it cons\u0000tutes one of the core features of the func\u0000onal programming style. Here, we illustrate it with a simple example (from [FP-Scala]) The following func\u0000on builds a forma\u0000ed string to document the result of an applica\u0000on of the a b s func\u0000on deﬁned earlier: s c a l a > d e f fo r m a t A b s ( n : I n t ) = v a l m s g = \" T h e a b s o l u t e v a l u e o f % d i s % d \" m s g . fo r m a t ( n , a b s ( n ) ) d e f fo r m a t A b s ( n : I n t ) : S t r i n g The body of the func\u0000on uses fo r m a t , a (rather convenient) predeﬁned method of type S t r i n g : in the case in ques\u0000on, it returns a copy of the string m s g on which it is invoked with the values of the arguments n and a b s ( n ) subs\u0000tuted for the occurrences of % d . The same forma\u0000ng exercise can be tried with the factorial func\u0000on we deﬁned in our previous lecture: s c a l a > d e f fo r m a t F a c t ( n : I n t ) = v a l m s g = \" T h e fa c t o r i a l o f % d i s % d \" m s g . fo r m a t ( n , fa c t ( n ) ) d e f fo r m a t F a c t ( n : I n t ) : S t r i n g As we can see, the two forma\u0000ng func\u0000ons are almost iden\u0000cal. In fact, we can iden\u0000fy the common pa\u0000erns and represent them uniformly as func\u0000on parameter that abstracts over the two and can be instan\u0000ated so as to capture their behavior. s c a l a > d e f fo r m a t ( n : I n t , n a m e : S t r i n g , f: I n t = > I n t ) = v a l m s g = \" T h e % s o f % d i s % d \" m s g . fo r m a t ( n a m e , n , f( n ) ) d e f fo r m a t ( n : I n t , n a m e : S t r i n g , f: I n t = > I n t ) : S t r i n g fo r m a t is an example of higher-order func\u0000on whose last parameter is a func\u0000on. Now fo r m a t A b s and fo r m a t F a c t can be obtained as instances of fo r m a t : d e f fo r m a t A b s ( n : I n t ) = fo r m a t ( n , \" a b s \" , a b s ) d e f fo r m a t F a c t ( n : I n t ) = fo r m a t ( n , \" fa c t \" , fa c t ) Clearly, now that we have fo r m a t we may use it to format the result of any I n t = > I n t func\u0000on (see the fo r m a t C u b e exercise below). Polymorphic Func\u0000ons So far we have only seen examples of monomorphic func\u0000ons that operate just on one type. O\u0000en, the power of higher-orderness is ampliﬁed by having func\u0000ons operate parametrically on types. Again, this is a feature that we will discuss in detailed in the coming lectures, but it’s good to introduce the idea right away. The following func\u0000on returns the ﬁrst index at which a given string k e y occurs in an array of strings. , d e f fi n d F i r s t ( s t r i n g s : A r r a y [ S t r i n g ] , k e y : S t r i n g ) : I n t = @ a n n o t a t i o n . t a i l r e c d e f l o o p ( n : I n t ) : I n t = i f n > = s t r i n g s . l e n g t h t h e n -1 e l s e i f s t r i n g s ( n ) = = k e y t h e n n / / ` s t r i n g s ( n ) ` e x t r a c t s t h e n ' t h e l e m e n t e l s e l o o p ( n + 1 ) l o o p ( 0 ) The details are not that important here. What’s important is that the code for this func\u0000on would look iden\u0000cal if we were searching an I n t in an A r r a y [ I n t ] , or more generally an A on any A r r a y [ A ] . In this la\u0000er case, however, we need to abstract away from the equality test used above: that can be done by making the func\u0000on parametric in a further parameter represen\u0000ng a tester func\u0000on: d e f p o l y F i n d F i r s t [ A ] ( a s : A r r a y [ A ] , k e y : A , p : A = > B o o l e a n ) : I n t = @ a n n o t a t i o n . t a i l r e c d e f l o o p ( n : I n t ) : I n t = i f n > = a s . l e n g t h t h e n -1 e l s e i f p ( a s ( n ) ) t h e n n e l s e l o o p ( n + 1 ) l o o p ( 0 ) This is an example of polymorphic, or generic (higher-order) func\u0000on. We are abstrac\u0000ng over the type of the array and the func\u0000on used to search the array. The type parameter A can be referenced in the body of the func\u0000on (as well as in the parameter list as it happens in this case). Exercises 1. Tail recursive Fibonacci Write a tail recursive version of the Fibonacci func\u0000on. Note: The mathema\u0000cal deﬁni\u0000on of the Fibonacci numeral sequence is as follows: If we look at the call tree (below), we easily see its exponen\u0000al growth. The tail recursive deﬁni\u0000on is one way to avoid this exponen\u0000al complexity. Hint: use two accumulators for the values of ﬁb (n) and ﬁb(n+1) fib(0) = 0 fib(1) = 1 fib(n) = fib(n-1) + fib(n-2) 2. Count change Given a list of coin denomina\u0000ons, write a recursive func\u0000on c o u n t _ c h a n g e ( c o i n s : L i s t [ I n t ] , a m n t : I n t ) : I n t that counts the number of unique (up to re- orderings of the coins used) ways to make change. Examples: count_change(List(1,5,10,25), 11) = 4 because 11 = 1+1+1+1+1+1+1+1+1+1+1 = 1+1+1+1+1+1+5 = 1+5+5 = 1+10 count_change(List(List(5, 2, 3), 10) = 4 because 10 = 5+5 = 2+3+5 = 2+2+2+2+2 = 2+2+3+3 count_change(List(List(1, 2), 4) = 3 4 = 1+1+1+1 = 1+1+2 = 2+2 Hint. For the base case, there are two possibili\u0000es: If the target amount is 0, there is only one way to make the sum, which is by not selec\u0000ng any coin, so the count is 1. If the target sum amount is nega\u0000ve or no coins are le\u0000 to consider , then there are no ways to make the amount, so the count is 0 Otherwise, chosen any coin in the list, there are 2 op\u0000ons. include the coin: Subtract the coin’s denomina\u0000on from the target sum and call the count func\u0000on recursively with the updated sum and the same list of coins exclude the coin: Call the count func\u0000on recursively with the same sum and the remaining coins. The ﬁnal result will be the sum of both cases.] 3. More forma\u0000ng Use the higher-order fo r m a t func\u0000on deﬁned earlier to deﬁne fo r m a t _ c u b e : I n t = > S t r i n g , to format the cube func\u0000on (i.e. the func\u0000on that given an n returns n to the power of 3). 4. Find ﬁrst occurrence of string: Deﬁne the fi n d F i r s t func\u0000on as an instance of p o l y F i n d F i r s t opera\u0000ng on strings. 5. Check that list is sorted We want a func\u0000on s o r t e d [ A ] ( a s : L i s t [ A ] , l t e : ( A , A ) = > B o o l e a n ) : B o o l e a n which checks whether a s : L i s t [ A ] is sorted according to a given comparison func\u0000on l t e (the la\u0000er returns true if its ﬁrst argument is less than or equal to its second argument, false otherwise). Write two versions of s o r t e d , using recursion and tail-recursion, respec\u0000vely Write an invoca\u0000on of your func\u0000on s o r t e d to check that a given list of integers is sorted.","libVersion":"0.3.2","langs":""}