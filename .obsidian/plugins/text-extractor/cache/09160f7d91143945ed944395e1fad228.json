{"path":"System Security/Lecture 11- Trusted-Computing.pdf","text":"Trusted Computing System Security (CM0625, CM0631) 2024-25 Università Ca’ Foscari Venezia Riccardo Focardi www.unive.it/data/persone/5590470 secgroup.dais.unive.it Complex software systems are (eventually) ﬂawed Design ﬂaws: hard to provide the intended security guarantees Implementation ﬂaws: even when design is correct, bugs might introduce vulnerabilities Introduction 2 Can we mathematically prove security? Formal models of computer security can be used to “prove” that: ● design satisﬁes a set of security requirements ● implementation conforms to the design Introduction Formal models of security 3 Example: Bell - La Padula (BLP) Deﬁnition: Information should never ﬂow from a level to lower ones ● Simple security: Subjects cannot read from objects at a higher level ● *-property: Subjects cannot write into objects classiﬁed at a lower level (plus standard DAC) Secret Public write write read read write up read down 4 Example: Bell - La Padula (BLP) Secret Public no write down no read up Forbidden! Deﬁnition: Information should never ﬂow from a level to lower ones ● Simple security: Subjects cannot read from objects at a higher level ● *-property: Subjects cannot write into objects classiﬁed at a lower level (plus standard DAC) 5 Example: Bell - La Padula (BLP) Secret Public Forbidden! no write down no read up Deﬁnition: Information should never ﬂow from a level to lower ones ● Simple security: Subjects cannot read from objects at a higher level ● *-property: Subjects cannot write into objects classiﬁed at a lower level (plus standard DAC) 6 BLP model BLP can be stated formally Assume: S1, …,Sm subjects, O1, …,On objects, A1, …,Aw access modes (e.g., read, write, append, …) State: 3-tuple ( b, M, f), deﬁned as b : current access set of triples (Si, Oj, Ax) representing subject Si accessing object Oj in mode Ax M : access matrix of permitted access modes. Mij contains modes for subject Si accessing object Oj f : level function assigning a security level to subjects and objects f(Oj) is the security level of object Oj f(Si) is the security level of subject Si 7 BLP model Simple security: every triple of the form (Si, Oj, read) in the current access set b has the property f(Si) ≥ f(Oj) *-property: every triple of the form (Si, Oj, write) in the current access set b has the property f(Si) ≤ f(Oj) In addition to MAC, BLP also enforces DAC, in terms of the access control matrix M. DAC is formalized as follows: ds-property: if (Si, Oj, Ax) is a current access in b, then access mode Ax is present in Mij. That is (Si, Oj, Ax) ∈ b ⇒ Ax ∈ Mij 8 BLP secure state In summary, we say that a state (b, M, f) is secure iff Simple security: ∀ i j . (Si, Oj, read) ∈ b ⇒ f(Si) ≥ f(Oj) *-property: ∀ i j . (Si, Oj, write) ∈ b ⇒ f(Si) ≤ f(Oj) ds-property: ∀ i j x . (Si, Oj, Ax) ∈ b ⇒ Ax ∈ Mij 9 BLP abstract operations Get access: initiate access to object, i.e., add (Si, Oj, Ax) to b Release access: release access to object, i.e., remove (Si, Oj, Ax) from b Change object level: change the value of f(Oj) for some object Oj Change subject level: Change the value of f(Si) for some subject Si Give access permission: grant an access mode, i.e., add Ax to Mij Revoke access permission: delete an access mode, i.e., remove Ax from Mij Create an object: add a new object Oj with security level f(Oj) Delete an object: remove object Oj 10 Security of abstract operations Get access: add (Si, Oj, read) to b f(Si) ≥ f(Oj) and read ∈ Mij Get access: add (Si, Oj, write) to b f(Si) ≤ f(Oj) and write ∈ Mij Change object/current level: change the value of f(Oj) (similarly for f(Si)) ∀ i . (Si, Oj, read) ∈ b ⇒ f(Si) ≥ f(Oj) ∀ i . (Si, Oj, write) ∈ b ⇒ f(Si) ≤ f(Oj) Revoke access permission: remove Ax from Mij (Si, Oj, Ax) ∉ b When action violates the condition ● action is forbidden (error), or ● state should be updated, e.g., release accesses that violate the new permissions or levels (make the state secure) 11 BLP security proof Secure state: state (b, M, f) is secure if and only if every element of b satisﬁes the three properties State transition: state (b, M, f) is changed by any operation that changes b, M or f Security Theorem: a system starting from a secure state is secure iff any operation preserves the three properties (can be formally proved) It is theoretically possible to prove that an actual implementation (or system design) is secure by proving that any action that affects the state of the system satisﬁes the three properties For a complex system, such a proof can hardly cover all cases ⇒ Still, formal proof can lead to more secure design and implementation 12 Applications of BLP model 13 Implementing BLP in RBAC (1) Constraint on users: For each subject s a security clearance L(s) is assigned Permissions: For each role r and object o, assign read/write permission (access matrix) Constraint on objects: For each object o a security classiﬁcation L(o) is assigned The read-level of a role r, denoted r-level(r), is the least upper bound of the security levels of the objects for which read is in the permissions of r The write-level of a role r, denoted w-level(r), is the greatest lower bound of the security levels of the objects for which write is in the permissions of r 14 Implementing BLP in RBAC (2) Constraint on role assignment: the clearance of the subject must dominate the r-level of the role and be dominated by the w-level of the role L(S) ≥ r-level(r) L(S) ≤ w-level(r) The r-level of the role indicates the least security classiﬁcation that dominates the level of objects readable from the role Simple security property demands that a subject is assigned to a role only if the subject’s clearance is at least as high as the r-level of the role (dually for write access, *-property) 15 Trust: conﬁdence that system meets speciﬁcations, e.g., through formal analysis or code review Trusted computing base (TCB): part of the system enforcing a particular policy, small enough to be analyzed Evaluation: assessing if system has the claimed security properties Trusted systems 20 Trusted Platform Module (TPM) TPM is a hardware module that is at the heart of a hardware/software approach to trusted computing Standardized by the Trusted Computing Group TPM is integrated in the CPU, the motherboard, or in smarcards It is a hardware, tamper resistant Trusted Computing Base (TCB) The TPM works with TC-enabled software, including the OS and applications The software can be assured that the data it receives are trustworthy, and the system can be assured that the software itself is trustworthy Three basic services: authenticated boot, certiﬁcation, and encryption 21 Authenticated boot service Responsible for booting the entire operating system, assuring that it is an approved version for use Boot happens in stages: ● Boot ROM is loaded ● Boot Block on storage is loaded ● Larger blocks are brought in, until the full OS is loaded At each stage, the TPM checks that valid software has been brought in, e.g. verifying a digital signature associated with the software The TPM keeps a tamper-evident log of the loading process ⇒ a cryptographic hash function is used to detect any tampering with the log 22 Authenticated boot service The tamper-evident log contains a record that establishes exactly, which version of the OS and which of its modules are running Trust boundary can be expanded to include additional hardware and application and utility software ⇒ approved list of hardware and software components The TC-enabled system checks whether any new component ● is on the approved list ● is digitally signed ● has a serial number that has not been revoked ⇒ hardware, system software, and applications in a well-deﬁned state with approved components. 23 Certiﬁcation service A mechanism to certify the (trusted) conﬁguration to other parties The TPM produces a digital certiﬁcate by signing a description of the conﬁguration information using the TPM’s private key Other local or remote parties have conﬁdence that an unaltered conﬁguration is in use Notice that: ● TPM is trustworthy (no need of a further certiﬁcation of the TPM) ● Only the TPM possesses this particular private key ● TPM’s public key can be used to verify the signature ● Hierarchical trust: TPM certiﬁes hardware/OS, OS can certify applications, etc. 24 Preventing replay attacks An attacker might 1. intercept TPM certiﬁcation 2. compromise the system 3. “replay” the certiﬁcation when needed to prove trustworthiness of the attacked system Solution: TPM includes a random challenge R from the requester in the signature to prevent “replays” TPM SignPK(conﬁg) SignPK(conﬁg) TPM SignPK(R, conﬁg) SignPK(R, conﬁg) R R’ R ≠ R’ reject! 25 Encryption Enables the encryption of data in such a way that the data can be decrypted only by a certain machine, and only if that machine is in a certain (trusted) conﬁguration Idea: one master secret key used to derive many encryption keys, one for each trusted conﬁguration ⇒ decryption is possible only in the same conﬁguration Hierarchical trust: provide an encryption key to a (certiﬁed) application so that the application can encrypt data Decryption can only be done by the desired version of the desired application running on the desired version of the desired OS Even remote, if TPMs share master keys 26 Example: protected storage File encrypted and saved in a local storage The encryption key is encrypted by the TPM using the master key and stored together with the ﬁle The encrypted key is associated to the speciﬁcation of hardware / software conﬁguration that is authorized to access the key Application requests to decrypt the encrypted key: 1. TPM veriﬁes that hardware / software conﬁguration matches the required one 2. TPM decrypts the key and passes it to the application 3. Application decrypts the ﬁle and is trusted to discard the key 27","libVersion":"0.3.2","langs":""}