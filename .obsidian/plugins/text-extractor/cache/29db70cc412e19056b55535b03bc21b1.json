{"path":"Advanced Programming/PDFs/5-A. Inductive Definitions.pdf","text":"ADVANCED PROGRAMMING LANGUAGES Fall 2024, CM 0632. MSc in Computer Science and Informa\u0000on Technology, Ca’ Foscari University of Venice Induc\u0000ve Deﬁni\u0000ons Before we proceed, we introduce a general scheme of induc\u0000ve deﬁni\u0000ons and we study the corresponding general induc\u0000on principle that derives from it. Both these no\u0000ons provide important technical tools instrumental to formalize most of the core no\u0000ons in the theory of programming languages we will approach along the course. An induc\u0000ve deﬁni\u0000on is a construc\u0000ve way to introduce a set (o\u0000en a set of tuples forming a rela\u0000onship). It consists of a family of rules to derive judgements (i.e. asser\u0000ons, statements) establishing a rela\u0000onships among two or more object. Examples include equality judgement such as , typing judgements ( has type ), evalua\u0000on judgements, ( reduces to ), membership judgements ( is a term in the set ). Induc\u0000ve rules have the following general structure: and are judgements of the form being deﬁned: the judgements above the line are called premises of the rule, and the judgement below the line is called its conclusion. A rule with no premises ( ), is an axiom, otherwise it is a proper inference rule. An inference rule can be read as sta\u0000ng that the premises are suﬃcient condi\u0000ons for the conclusion: that is to say, to show it is enough to show . An axiom states that its conclusion holds uncondi\u0000onally. An induc\u0000ve set of rules deﬁnes the strongest judgement form (i.e. the minimal rela\u0000on described by the judgement form) that is closed under the rules. More precisely: To be closed under the rules means that the rules are suﬃcient to derive the judgements: a judgement holds if there is a way to obtain it by composing the given rules. To be the strongest judgement form closed under the rules means that the rules are also necessary to derive the judgements : a judgement holds only if there is a way to obtain it by composing the rules. M = N M : T M T M → N M N M ∈ S M S J J ⋯ J 1 k J J , … , J 1 k J , … , J 1 k J k = 0 J J , … , J 1 k J J Said diﬀerently, suﬃciency means that we may show that holds by deriving it by composing the rules; necessity means that it must have been derived by composing the rules. Rule composi\u0000on is formalized by the no\u0000on of deriva\u0000on. Deriva\u0000ons. A deriva\u0000on of a judgement is a ﬁnite composi\u0000on of rules that starts with axioms and end with that judgement. It can be thought of as a tree (viewed upside down) in which each node is a rule whose children are deriva\u0000ons of its premises. Then, to show that a judgement holds it is enough to ﬁnd a deriva\u0000on ending with . To illustrate, we give three examples of induc\u0000ve deﬁni\u0000ons. The deﬁni\u0000ons introduce judgment forms that predicate over elements of a given domain. Induc\u0000vely deﬁned natural numbers The set of natural numbers can be deﬁned induc\u0000vely by the following system of rules for the judgement We typically use rule schemes that use meta-variables to specify an inﬁnite family of rules on the terms build over the meta-variables. The ﬁrst rule states that belongs to . The second is a rule scheme that says that whenever belongs to , then also is in . Collec\u0000vely, the two rules deﬁne the minimal rela\u0000on described by the judgement closed under the induc\u0000ve rules, i.e., they construe as the minimal set of terms such that is closed under the induc\u0000ve rules. That, in turn, implies that all elements of may (and must!) be constructed by composing the rules in a deriva\u0000on. Thus, the numeral 2 is the result of the deriva\u0000on shown below: J J ⋯ J 1 J ⋯ J 1,1 1,n 1 J k J ⋯ J k,1 k,n k J J J(∙) ∙ ∈ Nat 0 ∈ Nat   succ(n) ∈ Nat n ∈ Nat 0 Nat n Nat succ(n) Nat n ∈ Nat Nat  n n ∈ Nat Nat succ(succ(0)) ∈ Nat succ(0) ∈ Nat 0 ∈ Nat Induc\u0000vely deﬁned λ terms Induc\u0000ve deﬁni\u0000ons are commonplace in the formaliza\u0000on of all aspects of programming language theory, from syntax to seman\u0000cs to type theory. BNF syntac\u0000c deﬁni\u0000ons, for instance, are nothing else than induc\u0000ve deﬁni\u0000ons, even though they rely on induc\u0000on only implicitly. For instance, the following is an induc\u0000ve deﬁni\u0000on of the set of lambda terms ( ) equivalent to the deﬁni\u0000on we gave in our earlier lecture with the more familiar BNF nota\u0000on. Induc\u0000vely deﬁned β-reduc\u0000on As a ﬁnal example, we formalize the no\u0000on of β-reduc\u0000on as a rela\u0000onship between two terms. In our previous lectures we have introduced β-reduc\u0000on in a rather informal way, by deﬁning the core rule that formalizes the behavior of applica\u0000on, transforming the redex into the reduct , and then arguing that we may reduce an expression as long as we reduce one redex of the expression. Full β reduc\u0000on. We now make this formal by deﬁning β-reduc\u0000on induc\u0000vely, by the following rule system for judgements of the form , rela\u0000ng two terms. The ﬁrst axiom is the β-reduc\u0000on rule we have introduced in the ini\u0000al presenta\u0000on of the λ- calculus. The addi\u0000onal rules provide us with a formal device to apply the reduc\u0000on inside terms – speciﬁcally (i) inside the term in func\u0000on posi\u0000on of an applica\u0000on , (ii) inside the argument of an applica\u0000on and, ﬁnally, (iii) inside a λ-abstrac\u0000on. The Principle of Rule Induc\u0000on The principle of rule induc\u0000on is a generaliza\u0000on of the following, well-known principle of induc\u0000on on natural numbers: Let be any property of natural numbers. Suppose holds of zero, and whenever holds of a natural number then it holds of its successor, . Then holds of every natural number. Lam x, y, z ∈ Lam   λx.M ∈ Lam M ∈ Lam M N ∈ Lam M ∈ Lam N ∈ Lam (λx.M )N [N /x]M ∙ →1 ∙ 2 (λx.M )N → [N /x]M   M N → M N′ M → M ′ M N → M N ′ N → N ′ λx.M → λx.M ′ M → M ′ P P P n n + 1 P Rule induc\u0000on generalizes this principle to reason about induc\u0000vely deﬁned sets (or rela\u0000ons) and their proper\u0000es. The principle of rule induc\u0000on states that to show that a property holds whenever is derivable, it is enough to show that is closed under, or respects, the rules deﬁning the judgment form . More precisely, the property respects the rule if holds whenever do. The assump\u0000ons are called the induc\u0000ve hypotheses, and is called the conclusion of the inference. Applying the principle to prove a property for our induc\u0000vely deﬁned natural amounts to show that respects the two rules deﬁning the judgement . That, in turn, requires us to show that 1. holds, 2. if holds for a given (arbitrary ), so does This is just the familiar induc\u0000on principle on natural numbers. Similarly, proving that a given property holds of all lambda terms, amounts to show that 1. holds for any variable 2. if holds for any given term , then so does 3. if and both hold true for arbitrary terms and , then so does Rule induc\u0000on applies as well to induc\u0000vely deﬁned rela\u0000ons. For instance, to prove a given property of (full) β-reduc\u0000on, we must show the following: 1. holds of for any two (arbitrary) terms and 2. if holds of then so does of , of and of Exercises 1. Expressions, deﬁned induc\u0000vely Express the syntax of expression language with an induc\u0000ve deﬁni\u0000on for the judgement P (a) J(a) P J P J(a) J(a ) ⋯ J(a )1 k P (a) P (a ), … , P (a )1 k P (a ), … , P (a )1 k P (a) P P ∙ ∈ Nat P (0) P (n) n P (succ(n)) P P (x) x P (M ) M P (λx.M ) P (M ) P (N ) M N P (M N ) P P (λx.M )N → [N /x]M M N P M → M ′ M N → M N ′ N M → N M ′ λx.M → λx.M ′ M ∈ . 2. Induc\u0000on and Induc\u0000on Principle Let the set of integers Q be deﬁned induc\u0000vely as follows: Exercise 2.1. Answer the following: Of the rules above (i.e., RULE1, RULE2, and RULE3), which are axioms and which are induc\u0000ve rules? Give a deriva\u0000on showing that 11 is in the set Q. Give a deriva\u0000on showing that 20 is in the set Q. Exercise 2.2. Write down the induc\u0000ve principle for Q. That is, if you wanted to prove that for some property P, for all a ∈ Q we have P(a), what would you need to show? Exercise 2.3. Is 2 in the set Q? If so, give a deriva\u0000on proving it. Otherwise, ﬁgure out a way to disprove it (Hint: in the la\u0000er case, prove some property that holds true of all elements of Q and is not true of 2). 3. Induc\u0000on and reduc\u0000on in λ-calculus Recall the deﬁni\u0000on of the recursion operator   def Y = λf.(λx. f(x x)) (λx. f(x x)) Exercise 3.1. Let F be a normal-form term.   - exaluate (Y F) using applica\u0000ve order   - evaluate (Y F) using normal order Exercise 3.2. Assume we have an applied lambda calculus with integers, booleans and condi\u0000ons and consider the following high-level deﬁni\u0000on of add:   def add = add = λf.λa.λb. (if a = 0 then b else f(a-1)(b+1) Now show the the computa\u0000on of (add 2 1) recursively using Y. You don’t need to expand any operators except Y and add, and those only when necessary. In other words, show that (Y add) 2 1 = 3 Exercise 3.3. Assume we have an applied lambda calculus with integers, booleans, condi\u0000onals, etc. Consider the following higher-order func\u0000on H.   H = λf. λn. if n = 1 then true else if n = 0 then false else not (f (n − 1)) Exp RULE1     RULE2     RULE3     8 ∈ Q 5 ∈ Q c ∈ Q a ∈ Q b ∈ Q [c = a + b + 1] Suppose that g is the ﬁxed point of H. What does g compute? Compute (Y H) with CBN seman\u0000cs. What happens to the call f (n − 1)? Compute (Y H) 2 with CBN seman\u0000cs. CREDITS The material on induc\u0000on and rule induc\u0000on are taken from Robert Harpers’s book on Prac\u0000cal Founda\u0000ons of Programming Languages (second edi\u0000on). Cambridge University Press, 2016.","libVersion":"0.3.2","langs":""}