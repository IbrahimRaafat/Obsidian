{"path":"Advanced Programming/PDFs/9. ATDs in Programming Languages.pdf","text":"ADVANCED PROGRAMMING LANGUAGES Fall 2024, CM 0632. MSc in Computer Science and Informa\u0000on Technology, Ca’ Foscari University of Venice ADTs in Programming Languages We complete the discussion on algebraic datatypes with a deeper dive on their implementa\u0000on in diﬀerent programming languages Nominal vs Structural Type Systems Following a common prac\u0000ce in type theore\u0000c datatypes presenta\u0000ons, so far we have adopted a purely structural presenta\u0000on that introduces new type expressions reﬂec\u0000ng the structure of the datatypes the type expressions are associated with. In programming languages, datatypes are most o\u0000en introduced with names to stand for long or complex type expressions to improve the readability of examples. e.g.: Such deﬁni\u0000ons are some\u0000mes pure abbrevia\u0000ons: the names are just shorthands for the type expressions and they are interchangeable with the type expressions in any context. By contrast, programming languages most o\u0000en adopt a diﬀerent approach, known as nominal typing. In a nominal type system: every compound type must be explicitly introduced by a declara\u0000on before being used; each type name must be declared at most once, and following their declara\u0000ons, types must always be referred to by their names Nominal type systems have both advantages and disadvantages over structural presenta\u0000ons. The most signiﬁcant advantage is probably that the type names in nominal systems are useful not only during type- checking, but at run \u0000me as well. Most nominal languages tag each run-\u0000me object with a header containing its type name, represented concretely as a pointer to a run-\u0000me data structure describing the type. These type tags are handy for a variety of purposes, including run-\u0000me type tes\u0000ng (e.g., Java’s instanceOf tests and downcas\u0000ng), prin\u0000ng, marshaling data structures into binary forms, . . . etc. A less essen\u0000al, but pleasant, property of nominal systems is that they oﬀer a natural and intui\u0000ve account of recursive types. Such types are ubiquitous in serious programming, being required to describe such common structures as lists and trees. Nominal type systems support them in the most straigh\u0000orward possible way: referring to in the body of its own declara\u0000on is just as easy as referring to any other type. IntPair A ddress = = { fst : Int,  snd : Int} { city : String,  street : String,  number : Int} List Structural systems, in turn, are appealing in that they are somewhat \u0000dier and more elegant. In a structural se\u0000ng, a type expression is a closed en\u0000ty: it carries with it all the informa\u0000on that is needed to understand its meaning (by contrast, in a nominal system, we are always working with respect to some global collec\u0000on of type name-deﬁni\u0000on pairs). Recursive types can also be handled structurally, by introducing type-level recursive operators (e.g. or operators on types), though capturing complex schemes of mutually recursive deﬁni\u0000ons becomes somewhat heavy with such operators. All in all, the usefulness of type tags and the simple treatment of recursive types are decisive beneﬁts for the prac\u0000ce of programming, and hence it is no surprise to ﬁnd that nominal type systems are the norm in mainstream programming languages, with few excep\u0000ons. Structural typing in SML. Standard ML (SML) is an early dialect of the ML language that adopts a purely structural type systems. In SML record types are introduced just as we have done above. In fact, SML provides a mechanism for type declara\u0000ons, but (i) such declara\u0000ons are not mandatory to introduce a type and (ii) when they are used, they introduce type names as simple aliases for the record type they are associated with. Thus, the following are all legal in SML: t y p e I n t P a i r = { fs t : I n t , s n d : I n t } t y p e A d d r e s s = { c i t y : S t r i n g , s t r e e t : S t r i n g , n u m b e r : I n t } v a l p 1 : I n t P a i r = { fs t = 2 , s n d = 3 } v a l p 2 : { s n d : I n t , fs t : I n t } = p 1 v a l a 1 : A d d r e s s = { c i t y = \" B o s t o n \" , s t r e e t = \" W o r c e s t e r \" , n u m b e r = 1 5 } v a l a 2 : { c i t y : S t r i n g , s t r e e t : S t r i n g , n u m b e r : I n t } = a 1 Nominal Typing in Haskell Record types. Haskell record types are product types with addi\u0000onal syntax to provide a convenient naming (and access) scheme for the product posi\u0000ons. For example the following is the Haskell version of the datatypes deﬁned earlier: d a t a P a i r = P a i r { fs t : : I n t , s d n : : I n t } d a t a A d d r e s s = A d d r { c i t y : : S t r i n g , s t r e e t : : S t r i n g , n u m b e r : : I n t } l e t p = P a i r { fs t = 5 , s n d = 3 } l e t a = A d d r { c i t y = \" B o s t o n \" , s t r e e t = \" W o r c e s t e r \" , n u m b e r = 1 5 } Both types are introduced by a d a t a declara\u0000on, which deﬁnes the new type name introduces the data constructor to build the elements of the type’s domain: for the type P a i r the type and data constructors have the same name, whereas for addresses A d d r e s s is the type constructor, while A d d r is the data constructor. Types introduced by a d a t a declara\u0000on are unique and so are the data constructors introduced with them: the labels used to iden\u0000fy the record type ﬁelds are also unique, and may not be reused in other (record) types. Type aliases also exist in Haskell, to create synonyms for exis\u0000ng types names or expressions: they are introduced by the keyword t y p e : no\u0000ce, however, that unlike d a t a declara\u0000ons, t y p e declara\u0000ons do fix rec not introduce any data constructor, hence no new data domain, only a new type name for an exis\u0000ng data domain. In that respect, Haskell t y p e declara\u0000ons are much like t y p e d e f declara\u0000ons in C. Variant Types Haskell variant types are deﬁned by a d a t a declara\u0000on which introduces the new type constructor and one or more domain constructors, each of which may have zero or more arguments. t y p e R a d i u s = D o u b l e t y p e S i d e = D o u b l e d a t a S h a p e = C i r c l e R a d i u s | R e c t a n g l e S i d e S i d e d a t a I n t L i s t = E m p t y | C o n s I n t I n t L i s t The ﬁrst two type deﬁni\u0000ons introduce two name aliases for the type D o u b l e : their purpose is merely to document the intended meaning of the arguments of the two data constructors C i r c l e and R e c t a n g l e associated with the type S h a p e . As a result of the declara\u0000on, the type S h a p e is univocally iden\u0000ﬁed by its name, and circles and rectangles built with the data constructors may only be associated with type S h a p e . This also solves the tagging problem with stuctural typing and variant types we discussed in the last lecture. I n t L i s t is a further datatype, which illustrates the use of data constructors with no argument, like E m p t y in a recursive deﬁni\u0000on of a type I n t L i s t which represents lists of integers: as an\u0000cipated, the use of nominal types makes the deﬁni\u0000on of recursive types par\u0000cularly simple and natural. Given the declara\u0000ons above, shapes and integer lists may be expressed simply as follows: l e t a _ c i r c l e : S h a p e = C i r c l e 3 . 0 l e t a _ l i s t : I n t L i s t = C o n s 5 ( C o n s 3 ( C o n s 4 E m p t y ) ) Nominal typing in Scala Records as (case) classes In Scala, like in other object oriented languages (most notable Java), records and record types are somehow subsumed by objects and classes. There is a fundamental diﬀerence between objects and records in that methods of objects have access to the objects’ structure (other methods and ﬁelds) whereas records simply collect ﬁelds without providing any cross-referencing mechanism among them. The key to this dichotomy is the implicit parameter that object methods can count on as a primi\u0000ve mechanism to access the hos\u0000ng object as a self-reference. Having said that, recent versions of Java have introduced special constructs to provide for a representa\u0000on of data structures fully coherent with the typing of records found in other func\u0000onal programming languages. Scala also has a construct that severs the purpose: case classes, Case classes are like regular classes with a few special features that make them eﬀec\u0000ve for modelling algebraic datatypes. We illustrate such features with the Scala implementa\u0000on of the datatypes discussed above. c a s e c l a s s P a i r ( fs t : I n t , s n d : D o u b l e ) c a s e c l a s s A d d r e s s ( c i t y : S t r i n g , s t r e e t : S t r i n g , n u m b e r : I n t ) this The two declara\u0000ons introduce two cases classes whose name serves both as type and as domain constructor. For each case class, Scala automa\u0000cally generates a primary data constructor so that case class instances may be constructed using the class name as a constructor (without n e w ). As a result, the following two declara\u0000ons introduce, respec\u0000vely a P a i r and an A d d r e s s v a l p = P a i r ( 5 , 3 ) v a l a = A d d r e s s ( \" B o s t o n \" , \" W o r c e s t e r \" , 1 5 ) Case classes have a variety of useful features that make them diﬀerent from standard classes and construe them as a faithful proxy of records in func\u0000onal languages: they are immutable, they come with a neat implementa\u0000on for equality (instances of case classes are always compared structurally), and with a number of addi\u0000onal useful operators and methods. Most notably, however, as Odersky, Spoon, and Venners note in their Scala book, “the biggest advantage of case classes is that they support pa\u0000ern matching.” Variant Types with Enumera\u0000ons In Scala, variant datatypes may be deﬁned either with e n u m declara\u0000ons or with systems of case classes. We look at enumera\u0000ons ﬁrst, as they provide for a more convenient and intui\u0000ve representa\u0000on than systems of case classes: e n u m S h a p e : c a s e C i r c l e ( r a d i u s : D o u b l e ) c a s e R e c t a n g l e ( w i d t h : D o u b l e , h e i g h t : D o u b l e ) e n u m I n t L i s t : c a s e E m p t y c a s e C o n s ( h d : I n t , t l : I n t L i s t ) As we see, Scala enumera\u0000ons are very much like datatypes deﬁni\u0000on in Haskell: the e n u m clause introduces a type name (the constructor of the new type) and the subsequent c a s e clauses deﬁne the data constructors for the type domain. In fact, as we will show in the upcoming lecture, e n u m declara\u0000ons turn out to be just (rather convenient) syntac\u0000c sugar for systems of case classes in which the type introduced in the e n u m clause is the common super-type of the types associated with the cases classes that implement the c a s e clauses of the enumera\u0000on. The implementa\u0000on of enumera\u0000ons with cases classes is almost transparent, except for one detail: to access the data constructors associated with the e n u m declara\u0000on, one has to explicitly get them in scope with an explicit import declara\u0000on. Given the two enumera\u0000ons, we may thus use them to build shapes and integer lists as follows: i m p o r t S h a p e . { C i r c l e , R e c t a n g l e } i m p o r t I n t L i s t . { E m p t y , C o n s } v a l a _ c i r c l e : S h a p e = C i r c l e 3 . 0 l e t a _ l i s t : I n t L i s t = C o n s ( 5 , C o n s ( 3 , C o n s ( 4 , E m p t y ) ) ) A detour on Scala classes Just as in Java, Scala classes are the blueprint (and the type) for objects: once we deﬁne a class, we can create objects from the class using the keyword n e w . A class deﬁni\u0000on can contain ﬁeld and method declara\u0000ons: the former (declared as modiﬁable v a r iable or immutable v a l ues) hold the data of the objects of the class, while methods, introduced with the keyword d e f contain executable code that has access to the class objects’ ﬁelds. Here is an example class deﬁni\u0000on for a person: c l a s s P e r s o n ( v a l n a m e : S t r i n g , v a l a g e : I n t ) : d e f a p p e n d T o N a m e ( s u ffi x : S t r i n g ) : P e r s o n = n e w P e r s o n ( s \" $ n a m e $ s u ffi x \" , a g e ) v a l p e r s o n = n e w P e r s o n ( \" G i o v a n n i \" , 5 3 ) This P e r s o n class has three members: the ﬁelds n a m e and a g e and the method a p p e n d T o N a m e . Unlike many other OO languages, the class deﬁni\u0000on includes the signature ( v a l n a m e : S t r i n g , v a l a g e : I n t ) of the primary constructor (other constructors may be deﬁned in the companion object, see below). The a p p e n d T o N a m e method takes a string argument and returns another P e r s o n Parameters without v a l or v a r are private values, and visible only within the class. Class members declared inside the class are public by default. The p r i v a t e access modiﬁer to hide them from outside of the class. As a result, to make a ﬁeld private, it must be declared inside the class rather than via a constructor parameter. Side remark. Here, and throughout, we insist on func\u0000onal (stateless / immutable ) data structures. Having noted that, we remark that Scala provides full support for stateful object, whose state is deﬁned by v a r tagged parameters for the primary constructor (or equivalently, by v a r declara\u0000on of ﬁelds) just as in Java. Companion Objects A companion object is an o b j e c t that is declared in the same ﬁle as a c l a s s , and has the same name as the class. Companion objects are special cases of singleton objects, the mechanism that Scala provides to account for Java’s sta\u0000c methods: whereas Java’s sta\u0000c methods are deﬁned within classes, in Scala they are deﬁned as regular methods of singleton objects. Companion objects come with a variety of interes\u0000ng features. First, a companion object and its class can access each other’s private members (ﬁelds and methods). Because of that, companion objects provide the natural scope to deﬁne methods (in fact, func\u0000ons) that operate on objects of the companion class. Among such methods, a companion object may deﬁne an a p p l y method to enable instances of the companion class to be created without the n e w keyword. What happens is that when you deﬁne an a p p l y method in a companion object, it has a special meaning to Scala, which in turn ac\u0000vates some useful syntac\u0000c sugar that lets you type code such as: v a l p e r s o n = P e r s o n ( \" G i o v a n n i \" , 5 3 ) and during the compila\u0000on process (or the REPL) Scala turns that code into this code: v a l p = P e r s o n . a p p l y ( \" G i o v a n n i \" , 5 3 ) The a p p l y method in the companion object acts as a factory method, and Scala’s syntac\u0000c sugar lets you use the syntax shown, crea\u0000ng new class instances without using the n e w keyword. To demonstrate how this feature works, here’s a companion object for class P e r s o n along with an a p p l y method that makes sure that P e r s o n s are ini\u0000alized with their name (if any) capitalized. o b j e c t P e r s o n : d e f a p p l y ( n a m e : S t r i n g , a g e : I n t ) : P e r s o n = v a l c a p s N a m e = i f ! n a m e i s E m p t y t h e n v a l fi r s t = n a m e . c h a r A t ( 0 ) . t o U p p e r v a l r e s t = n a m e . s u b s t r i n g ( 1 ) s \" $ fi r s t $ r e s t \" e l s e \" U n k n o w n \" n e w P e r s o n ( c a p s N a m e , a g e ) The following is the implementa\u0000on of the S h a p e type by a system of cases classes. s e a l e d t r a i t S h a p e c a s e c l a s s C i r c l e ( r a d i u s : D o u b l e ) e x t e n d s S h a p e c a s e c l a s s R e c t a n g l e ( b a s e : D o u b l e , h e i g h t : D o u b l e ) e x t e n d s S h a p e The ﬁrst line introduces a trait. Scala’s traits are similar to Java’s interfaces and abstract classes, and serve a similar purpose, namely to deﬁne a common interface (possibly with default method implementa\u0000ons) for a hierarchy of types. In this case, the trait deﬁnes a new type Shape (with empty interface) and is sealed, meaning that it cannot be extended outside the scope of the present declara\u0000on. Sealing provides is a form of protec\u0000on for class hierarchies similar to that oﬀered by fi n a l in Java: in addi\u0000on, when associated with datatype declara\u0000ons such as the one above, it helps the type-checker verify the use of pa\u0000ern matching on the case class instances of the trait. The subsequent two declara\u0000ons introduce two cases classes as a concrete implementa\u0000on of the trait: the subtyping rela\u0000on introduced by the e s t e n d s clause make C i r c l e and R e c t a g l e subtypes of S h a p e . As we noted earlier on, the class names serve both as types and as data constructors: this is possible thanks to the speciﬁc features that Scala provides for cases classes, as we discuss below. Primary constructors. First, for each case class, Scala automa\u0000cally generates a companion object and deﬁnes a factory method for the primary constructor so that case class instances may be constructed using the class name as a constructor (hence, without n e w ). As a result, the following two declara\u0000ons introduce, respec\u0000vely a C i r c l e and a R e c t a n g l e : by subtyping, both are also instances of S h a p e . e n u m S h a p e : c a s e C i r c l e ( r a d i u s : D o u b l e ) c a s e R e c t a n g l e ( w i d t h : D o u b l e , h e i g h t : D o u b l e ) v a l c i r c l e = C i r c l e ( 3 . 0 ) v a l r e c t a n g l e = R e c t a n g l e ( 5 . 0 , 1 8 . 0 ) No\u0000ce also that all arguments in the parameter list are listed without qualiﬁca\u0000on, hence they all get a v a l qualiﬁca\u0000on, which makes the immutable, automa\u0000cally. Equality and other u\u0000lity methods. In addi\u0000on to the factory method, Scala adds further deﬁni\u0000ons for methods t o S t r i n g , h a s C o d e and, perhaps more interes\u0000ngly, e q u a l s : the la\u0000er, in par\u0000cular, will compare instances by inspec\u0000ng the whole structure of the instances. Since Scala always delegates = = to e q u a l s , this means that element of cases classes are always compared structurally: in that respect, they can be considered a faithful representa\u0000on of records. While all of these features are great beneﬁts to func\u0000onal programming, as they write in the book, Odersky, Spoon, and Venners note that “the biggest advantage of case classes is that they support pa\u0000ern matching.” Pa\u0000ern matching is a major feature of FP languages, and Scala’s case classes provide a simple way to implement pa\u0000ern matching in match expressions and other areas. Pa\u0000ern matching We illustrate pa\u0000ern matching in Scala as a representa\u0000ve of a mechanism found in many programming language. Pa\u0000ern matching in Scala is an extension of the founda\u0000onal mechanism illustrated in our last lecture, which accommodates a variety of pa\u0000ern forms. A m a t c h expression e x p m a t c h c a s e p 1 = > e x p 1 . . . c a s e p n = > e x p n evaluates the expression e x p to be matched and then tries each of the pa\u0000erns p 1 to p n in the order they are listed. The ﬁrst pa\u0000ern that matches is selected, and the corresponding expression e x p i following the arrow is evaluated: no other match is a\u0000empted, (i.e. the execu\u0000on “falls through” into the next case.) If none of the pa\u0000erns match, an excep\u0000on M a t c h E r r o r is thrown. If the cases of a match do not cover the type of the expression to be matched, the type checker will issue a warning. There exist many kinds of pa\u0000erns in Scala other than the variable and constructor pa\u0000erns we have discussed. Matching on constant pa\u0000erns. Constant pa\u0000erns are simply a special case of constructor pa\u0000erns. The following code snippet shows some examples: d e f d e s c r i b e P a t t e r n s ( x : A n y ) = x m a t c h c a s e 5 = > \" fi v e \" c a s e t r u e = > \" t r u e \" c a s e \" h i \" = > \" h e l l o \" c a s e N i l = > \" e m p y l i s t \" Matching on case classes Matching on case classes is also a special use case of matching with constructors. In fact, it coincides with the corresponding matching expression for enumera\u0000ons: d e f a r e a ( s : S h a p e ) : D o u b l e = s m a t c h c a s e C i r c l e ( r ) = > M a t h . P I * M a t h . p o w ( r , 2 ) c a s e R e c t a n g l e ( b , h ) = > b * h If the root trait of the class hierarchy is sealed, as for type S h a p e , then the type checker can verify whether or not the cases of a match on root type is exhaus\u0000ve and issue the warning accordingly (that is because sealing ensures the type checker that no further case classes may extend the root outside the ﬁle being checked). matching with sequence pa\u0000erns. These are further special cases of constructor pa\u0000erns over the types L i s t and A r r a y . As an example, the following code snipped isolates three-element lists that start with a 0: x s m a t c h c a s e L i s t ( 0 , _ , _ ) = > . . . c a s e _ = > . . . Alterna\u0000vely, we can match against a sequence without specifying how long it can be, by introducing _ * as the last pa\u0000ern of the sequence pa\u0000ern: x s m a t c h c a s e L i s t ( 0 , _ * ) = > . . . c a s e _ = > . . . Typed pa\u0000erns. Typed pa\u0000erns represent a convenient replacement for type tests and type casts. We show an example below: d e f p e r i m e t e r ( s : S h a p e : D o u b l e = s m a t c h c a s e c : C i r c l e = > 2 * M a t h . P I * c . r a d i u s c a s e r : R e c t a n g l e = > 2 * ( r . b a s e + r . h e i g h t ) The code is similar to the one above, but no\u0000ce that use of the typed annota\u0000ons to test the “actual” type of s and eﬀec\u0000vely cast it to that type, once the test has succeeded. Pa\u0000ern guards. Pa\u0000erns in Scala (as ML and Haskell) are linear, which means that each variable may occur in a pa\u0000ern at most once. The only excep\u0000on is the wildcard, whose occurrences, however, are never related to one another. Pa\u0000ern guards provide a mechanism to get around this constraint. d e f i s S q u a r e ( s : S h a p e ) : B o o l e a n = s m a t c h c a s e R e c t a n g l e ( b , h ) i f b = = h = > t r u e c a s e _ = > fa l s e Variable binding. In addi\u0000on to standalone variable pa\u0000erns, variables may also be added to other pa\u0000erns as in x @ p where x is the variable and p the pa\u0000ern: the eﬀect is to match the pa\u0000ern as described above in addi\u0000on to binding the variable to the whole value being matched. Pa\u0000erns in variable deﬁni\u0000ons. Pa\u0000erns can be used anywhere a v a r or v a l declara\u0000on would be legal. The following example introduces a tuple pa\u0000ern in a declara\u0000on. Assuming t u p l e : ( I n t , S t r i n g ) the following destructs the tuple and binds the two pa\u0000ern variables: v a l ( n u m b e r , s t r i n g ) = t u p l e Case sequences in func\u0000on deﬁni\u0000ons A last interes\u0000ng use of pa\u0000erns is in case sequences to be used anywhere a func\u0000on literal can be used. Essen\u0000ally, a case sequence is a func\u0000on literal, only with more than one entry point, each speciﬁed with a corresponding pa\u0000ern. To illustrate, the a r e a func\u0000on deﬁned earlier can be deﬁned as follows: d e f a r e a : S h a p e = > D o u b l e = c a s e C i r c l e ( r ) = > M a t h . P I * M a t h . p o w ( r , 2 ) c a s e R e c t a n g l e ( b , h ) = > b * h As-pa\u0000erns in Haskell Case sequences in func\u0000on deﬁni\u0000ons are provided as a common programming prac\u0000ce in Haskell. Some\u0000mes it is convenient to name a pa\u0000ern for use on the right-hand side of an equa\u0000on. For example, the a r e a func\u0000on above could be wri\u0000en as follows: d a t a S h a p e = C i r c l e R a d i u s | R e c t a n g l e S i d e S i d e a r e a ( C i r c l e r ) = p i * ( r * * 2 ) a r e a ( R e c t a n g l e b h ) = b * h This is a special case of the general form of a func\u0000on deﬁni\u0000on by cases, which in Haskell may take the form: and is is seman\u0000cally equivalent to the following deﬁni\u0000on using a case expression: . Datatypes vs Objects in Scala We have already discussed the role of Scala classes in the implementa\u0000on of records and variants. Below we explore the rela\u0000onship between (case) classes and objects. We start by introducing an alterna\u0000ve implementa\u0000on of the S h a p e type by a system of cases classes. s e a l e d t r a i t S h a p e c a s e c l a s s C i r c l e ( r a d i u s : D o u b l e ) e x t e n d s S h a p e c a s e c l a s s R e c t a n g l e ( b a s e : D o u b l e , h e i g h t : D o u b l e ) e x t e n d s S h a p e The ﬁrst line introduces a trait. Scala’s traits are similar to Java’s interfaces and abstract classes, and serve a similar purpose, namely to deﬁne a common interface (possibly with default method implementa\u0000ons) for a hierarchy of types. In this case, the trait deﬁnes a new type Shape (with empty interface) and is sealed, meaning that it cannot be extended outside the scope of the present declara\u0000on. Sealing provides is a form of protec\u0000on for class hierarchies similar to that oﬀered by fi n a l in Java: in addi\u0000on, when associated with datatype declara\u0000ons such as the one above, it helps the type-checker verify the use of pa\u0000ern matching on the case class instances of the trait. The subsequent two declara\u0000ons introduce two cases classes as a concrete implementa\u0000on of the trait: the subtyping rela\u0000on introduced by the e s t e n d s clause make C i r c l e and R e c t a g l e subtypes of S h a p e . As f pattern … pattren = expr 11 1k 1 … f pattern … pattern = expr n1 nk n f x  x … x = case ( x , … , x )  of1 2 k 1 k p , … p → e 11 1k 1 … p , … p → e n1 nk n we noted earlier on, the class names serve both as types and as data constructors: this is possible thanks to the speciﬁc features that Scala provides for cases classes, as we discuss below. The deﬁni\u0000ons would typically be collected into a Scala package as follows: p a c k a g e F u n S h a p e s s e a l e d t r a i t S h a p e c a s e c l a s s C i r c l e ( r a d i u s : D o u b l e ) e x t e n d s S h a p e c a s e c l a s s R e c t a n g l e ( b a s e : D o u b l e , h e i g h t : D o u b l e ) e x t e n d s S h a p e d e f a r e a ( s : S h a p e ) : D o u b l e = s m a t c h c a s e C i r c l e ( r ) = > M a t h . P I * M a t h . p o w ( r , 2 ) c a s e R e c t a n g l e ( b , h ) = > b * h d e f s c a l e ( s : S h a p e , f: D o u b l e ) : S h a p e = s m a t c h c a s e C i r c l e ( r ) = > C i r c l e ( r * f) c a s e R e c t a n g l e ( b , h ) = > R e c t a n g l e ( b * f, h * f) The presenta\u0000on is in purely func\u0000onal style, with the system of trait and case classes serving as data structure deﬁni\u0000ons packaged with a set of func\u0000ons for working with S h a p e s. A corresponding object-oriented presenta\u0000on of the S h a p e datatype may be given as follows: p a c k a g e O O S h a p e s s e a l e d t r a i t S h a p e : d e f a r e a : D o u b l e d e f s c a l e ( f: D o u b l e ) : S h a p e c a s e c l a s s C i r c l e ( r a d i u s : D o u b l e ) e x t e n d s S h a p e : d e f a r e a : D o u b l e = M a t h . P I * M a t h . p o w ( r a d i u s , 2 ) d e f s c a l e ( f: D o u b l e ) : S h a p e = C i r c l e ( r a d i u s * f) c a s e c l a s s R e c t a n g l e ( b a s e : D o u b l e , h e i g h t : D o u b l e ) e x t e n d s S h a p e : d e f a r e a : D o u b l e = b a s e * h e i g h t d e f s c a l e ( f: D o u b l e ) : S h a p e = R e c t a n g l e ( b a s e * f, h e i g h t * f) Again, the presenta\u0000on introduces the system of trait and case classes to serve as data structure deﬁni\u0000ons. Unlike the func\u0000onal presenta\u0000on, however, the S h a p e opera\u0000ons are encoded as methods speciﬁed by the trait declara\u0000on and implemented by the two case classes implemen\u0000ng S h a p e . We will return to this later on in the course, when we discuss subtyping and Scala’s mechanisms for composi\u0000on and inheritance. Exercises 1. Compound Datatypes in Rust. Find out how ADTs are implemented in the programming language Rust. Speciﬁcally, provide answers to the following ques\u0000ons: how are records and variants represented in Rust how is pa\u0000ern matching implemented? does Rust adopt a nominal or structural approach to typing? 2. Lambda Calculus representa\u0000on in Scala We have covered enough material now to start coding some concrete example. In this exercise, you are asked to build a Scala representa\u0000on for the abstract syntax of the Lambda Calculus as deﬁned by the following produc\u0000ons: Deﬁne a type L a m b d a represen\u0000ng the abstract syntax for the set terms deﬁned by the previous produc\u0000ons. Hint: Use an enumera\u0000on or a system of cases classes. 3. Lambda Calculus Reduc\u0000on Write a set of func\u0000ons to simulate the reduc\u0000on rela\u0000on. More precisely, deﬁne: a func\u0000on fv to compute the free variables of a term; a func\u0000on s u b s t that implements the subs\u0000tu\u0000on of a variable for with a term in another, given term; a func\u0000on r e d u c e that implements the reduc\u0000on rela\u0000on, i.e. a func\u0000on r e d u c e such that r e d u c e ( M ) = N whenever is derived by the rule system below, where M and N are the Scala representa\u0000ons of the lambda terms and respec\u0000vely. Numeric Reduc\u0000ons Boolean Reduc\u0000ons Recursion Reduc\u0000ons M , N , P ::= ∣ ∣ ∣ ∣ ∣ ∣ ∣ x, y, z λx@ T .M M N n, m, k true  ∣ false M + N  ∣ M = N if M then N else P fix@ T .M variable abstraction application integers booleans conditional recursion M → N M N n + m → n + mN ( m and n numeric literals) M + m → M + m′ M → M ′ m + M → m + M ′ M → M ′ a = b → false ( a and b different constants) M = M → true M = N → M = N′ M → M ′ N = M → N = M ′ M → M ′ if true then M  else  N → M if false then M  else  N → N if M  then N  else  P → if M  then N  else  P′ M → M ′ fix@ T .M → M ( fix@ T .M ) fix@ T .M → fix@ T .M ′ M → M ′ Lambda Reduc\u0000ons 4. Lambda Calculus Typing Write a func\u0000on that implements the type checking rela\u0000on, i.e. i.e. a func\u0000on t y p e c h e c k such that t y p e c h e c k ( G , M ) = T whenever is derived by the rule system below, where G , M and T are the Scala representa\u0000ons of the typing context , the term and the type , respec\u0000vely. Lambda Terms Recursion Natural numbers and booleans CREDITS The discussion on nominal vs structural typing is taken from Chapter 19.3 of Prof. Benjamin’s Pierce’s book on Types and Programming Languages. MIT Press. 2001. The discussion on Scala datatypes (and objects) is based on Chapter 4, 13 and 19 of Programming in Scala (5th Edi\u0000on). M. Odersky, L. Spoon, B. Venners, F. Sommers. Ar\u0000ma Press. 2021. Please read those chapters for further informa\u0000on about pa\u0000erns and pa\u0000ern matching. ( λx.M ) N → [N / x]M   M N → M N′ M → M ′ M N → M N ′ N → N ′ λx.M → λx.M ′ M → M ′ Γ ⊢ M : T Γ M T Γ ⊢ x : T x : T ∈ Γ Γ ⊢ λx@ T .M : T → T 1 1 2 Γ, x : T ⊢ M : T 1 2 Γ ⊢ M N : T Γ ⊢ M : S → T Γ ⊢ N : S Γ ⊢ fix@ T .M : T Γ ⊢ M : T → T Γ ⊢ true : B ool   Γ ⊢ false : B ool   Γ ⊢ n : Nat   Γ ⊢ M + N : Nat Γ ⊢ M : Nat Γ ⊢ N : Nat Γ ⊢ M = N : B ool Γ ⊢ M : T Γ ⊢ N : T Γ ⊢ if M then N else P : T Γ ⊢ M : B ool Γ ⊢ N : T Γ ⊢ P : T","libVersion":"0.3.2","langs":""}