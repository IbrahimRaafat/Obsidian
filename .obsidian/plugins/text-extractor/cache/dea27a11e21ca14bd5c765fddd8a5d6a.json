{"path":"Advanced Programming/PDFs/1-B. Core Aspects of PL Design.pdf","text":"ADVANCED PROGRAMMING LANGUAGES Fall 2024, CM 0632. MSc in Computer Science and Informa\u0000on Technology, Ca’ Foscari University of Venice Core aspects of PL design If, on the one hand, the advances in technology have had the impact we just discussed in powering PL evolu\u0000on, on the other hand the design of programming languages suppor\u0000ng the desired abstrac\u0000ons has always been, and s\u0000ll is, anchored to few core aspects and key principles: the computa\u0000on model (or paradigm) adopted, whether impera\u0000ve, func\u0000onal, logical, object- oriented, concurrent; the data abstrac\u0000on mechanisms available for data representa\u0000on; the typing discipline provided to support program development the memory management and other low level tools employed to support an eﬀec\u0000ve use of the compu\u0000ng resources available for the computa\u0000on. Each of these core aspects provides an independent dimension for programming language categoriza\u0000on. Among them, the ﬁrst and most fundamental design decision concerns the computa\u0000on model, and speciﬁcally the choice of whether it should be impera\u0000ve or not. Impera\u0000ve vs func\u0000onal programming Impera\u0000ve languages are basically high-level, complex versions of the von Neumann computer. In its simplest form a von Neumann computer has three parts: a central processing unit (or CPU), a store, a bus connec\u0000ng the CPU and the store. Correspondingly, a program in an impera\u0000ve language has an implicit state (i.e., values of variables, program counters, etc.) that is modiﬁed (i.e., side-eﬀected) by constructs (i.e., commands, or instruc\u0000ons) in the source language. Such languages generally have an explicit no\u0000on of sequencing (of the commands) to permit precise and determinis\u0000c control of the state changes. These are the “conven\u0000onal” or “von Neumann languages” discussed by Backus in his 1977 Turing Award Address. They are well suited to tradi\u0000onal computer architectures, and to express how something is to be computed (as opposed to what is being computed). The following picture captures the essence of impera\u0000ve computa\u0000ons. The assignment statement is the core instruc\u0000on, whose eﬀect is to alter the underlying implicit store so as to yield a diﬀerent binding for a par\u0000cular variable. The begin . . . end construct is the prototypical sequencer of commands, as are the well-known condi\u0000onal statement (qualiﬁed sequencer), and while loop (an example of a structured command). With these simple forms, we can write programs like the one below: n : = x ; a : = 1 ; w h i l e n > O d o b e g i n a : = a * n ; n : = n -l e n d ; A quick look at the above code fragment is enough to tell that it computes the factorial of x . However, providing a compelling (i.e. mathema\u0000cally grounded) argument that the program does indeed compute what we expect it to compute requires some eﬀort. One way to accomplish that is by observing that the loop sa\u0000sﬁes the following invariant condi\u0000on: { a * n ! = = x ! } . To prove that, we can show that the condi\u0000on is veriﬁed at each itera\u0000on of the loop: at the ﬁrst itera\u0000on, the condi\u0000on is trivially true as a = = 1 and n = = x , at each further itera\u0000on, if we assume that { a * n ! = = x ! } before execu\u0000ng the body of the loop, than it is immediate to see that the condi\u0000on also holds at the end, as a * n ! = = ( a * n ) * ( n - 1 ) ! At the end of the last itera\u0000on the invariant is s\u0000ll valid, and n = = 0 : then since 0 ! = = 1 , from the invariant we have a = = x ! as desired. This simple example provides a clear illustra\u0000on of how impera\u0000ve code focuses on describing the steps involved in a computa\u0000on, rather than simply deﬁning the result. Every intermediate step, such as ini\u0000alizing variables and upda\u0000ng their values through itera\u0000ons, is stated explicitly: this provides precise control over the computa\u0000onal process, but also underscores how the code serves more as a recipe to achieve the result rather than a descrip\u0000on of the result itself. In this par\u0000cular example, the loop speciﬁes each individual step required to calculate the factorial of the given number, emphasizing the how to reach the result, as opposed to the what the result is. A substan\u0000al body of the exis\u0000ng languages are impera\u0000ve, including popular languages such as C++ and Java. Side remark. One may argue that C++ and Java are, in fact, object-oriented languages, and hence should be categorized accordingly. That is a fairly common approach in textbooks and in the academic literature, but we should bear in mind that object-orienta\u0000on, and similarly, concurrency, are second-\u0000er aspects in programming language design with respect to the fundamental branching between impera\u0000ve and non-impera\u0000ve (declara\u0000ve). Object orienta\u0000on, oﬀers mechanisms for data abstrac\u0000on, by providing a uniform access mechanism to data through the methods (procedures or func\u0000ons) collected in the interface that the data adver\u0000ses to its clients. Which such mechanism have proven eﬀec\u0000ve to organize large programs and code bases, they are fully amenable to implementa\u0000ons in impera\u0000ve languages (as in Java) as well as in func\u0000onal languages (as, e.g. in Scala). We’ll return to that shortly. Func\u0000onal programming In contrast to impera\u0000ve languages, computa\u0000on in func\u0000onal languages is the result of func\u0000on applica\u0000on and func\u0000on composi\u0000on. Programs are constructed as expressions represen\u0000ng func\u0000ons that are applied to the data they receive as input and compute values that they return as the result of their evalua\u0000on. As a result, computa\u0000ons in func\u0000onal languages are described very naturally by subs\u0000tu\u0000on (of the formal func\u0000on parameters with the actual arguments received as input) and rewri\u0000ng, without any reference to any implicit state or other underlying computa\u0000onal structure. Func\u0000on deﬁni\u0000ons can be as abstract as their pure mathema\u0000cal deﬁni\u0000ons. For example, here is the most direct deﬁni\u0000on of the factorial func\u0000on, which is indeed a valid func\u0000onal (Scala) program: d e f fa c t ( n : I n t ) : I n t = i f ( n < = 1 ) t h e n 1 e l s e n * fa c t ( n -1 ) State-oriented computa\u0000ons may s\u0000ll be accounted for with func\u0000ons, but accomplished by carrying the state around explicitly rather than implicitly. For example, a more eﬃcient (yet, certainly less intui\u0000ve) func\u0000onal implementa\u0000on of the factorial may be deﬁned as follows: d e f fa c t ( n : I n t ) = d e f fa c t o r i a l ( n : I n t , a c c : I n t ) : I n t = i f ( n < = 1 ) a c c e l s e fa c t o r i a l ( n - 1 , n * a c c ) fa c t o r i a l ( n , 1 ) The formal parameters n and a c c are examples of carrying the state around explicitly, and the recursive structure has been arranged so as to mimic as closely as possible the looping behavior of the program given earlier. Note that the condi\u0000onal in this program is an expression rather than command; that is, it denotes a value (condi\u0000onal on the value of the predicate) rather than a sequencer of commands. The value of the program is the desired factorial, rather than it being found in an implicit store. Func\u0000onal languages and func\u0000onal programming style Func\u0000onal languages are characterized by few key dis\u0000nguishing features: higher-order func\u0000ons (and, some\u0000mes, lazy evalua\u0000on) pa\u0000ern matching, various kinds of data abstrac\u0000on and polymorphism The combina\u0000on of these features is what qualiﬁes what is commonly referred to as func\u0000onal programming style, which we may deﬁne as a programming prac\u0000ce in which such features are manifest, and used extensively, whereas side eﬀects are strongly discouraged but not necessarily eliminated. The decision about including or excluding side eﬀects has very signiﬁcant consequences on modularity and on our ability to reason about program behavior: we’ll return to that below, in the closing sec\u0000on on referen\u0000al transparency. That said, adop\u0000ng a func\u0000onal programming style (whether including side eﬀects or not) has per se rather interes\u0000ng consequences. To make the point, we look at two examples. From impera\u0000ve to func\u0000onal style (1/2) We ﬁrst look at itera\u0000on, a powerful abstrac\u0000on used to traverse container objects such as lists, arrays and more generally, collec\u0000ons. In object oriented contexts, iterators are typically realized as objects associated with a collec\u0000on, and provide two methods to support the traversal of the collec\u0000on. To illustrate, consider a collec\u0000on of people from which we want to extract the age of the oldest male: the example is instruc\u0000ve as it also shows ho OO iterators may be implemented in impera\u0000ve as well as func\u0000onal se\u0000ngs. Our ﬁrst implementa\u0000on is in Java. Assume we are given a collec\u0000on p e o p l e : C o l l e c t i o n < P e r s o n > , where P e r s o n is a type providing two g e t methods to inspect the a\u0000ributes G e n d e r and A g e . The following code snippet computes maximal age of the males inside the collec\u0000on. / / C r e a t e a n e w i t e r a t o r fo r t h e c o l l e c t i o n I t e r a t o r < P e r s o n > i t = p e o p l e . i t e r a t o r ( ) ; i n t m a x A g e = -1 ; / / i t e r a t e o v e r t h e c o l l e c t i o n w h i l e ( i t . h a s N e x t ( ) ) { P e r s o n p = i t . n e x t ( ) ; i f ( p . g e t G e n d e r ( ) = = M A L E & & p . g e t A g e ( ) > m a x A g e ) m a x A g e = p . g e t A g e ( ) ; } This itera\u0000on is expressed in what we may deﬁne object-oriented impera\u0000ve style: object-oriented in the use of the iterator, impera\u0000ve in the structure of the loop that leaves the result in the variable m a x A g e . Since Java5, the code can be rephrased to make it more elegant, hiding the explicit use of the iterator by resor\u0000ng to the fo r -e a c h construct available on collec\u0000ons: i n t m a x A g e = -1 ; fo r ( P e r s o n p : p e o p l e ) i f( p . g e t G e n d e r ( ) = = M A L E & & p . g e t A g e ( ) > m a x A g e ) m a x A g e = p . g e t A g e ( ) ; With Java8 (similarly, in Scala) itera\u0000on can be rendered in func\u0000onal style, by resor\u0000ng to higher-order methods: fi n a l i n t m a x A g e = p e o p l e . s t r e a m ( ) . fi l t e r ( p -> p . g e t G e n d e r ( ) = = M A L E ) . m a p T o I n t ( p -> p . g e t A g e ( ) ) . m a x ( ) ; Here the data structure C o l l e c t i o n is used to produce a stream of elements that proceed through a pipeline of aggregate opera\u0000ons: the ﬁrst isolates the stream of males, the second creates a stream of ages from which the third collects the max element. You may at ﬁrst ﬁnd this kind of code diﬃcult to read because the nota\u0000on is compact and the ﬂow of control implicit. That is because when formula\u0000ng algorithms we are used to think in terms of how they should compute the intended result more than in terms of what they compute. A comparison between the last two code snippets is illumina\u0000ng: the impera\u0000ve implementa\u0000on is a perfect illustra\u0000on of how to proceed with the calcula\u0000on, which however leaves it to us to be convinced that the result is indeed what we expect to compute. On the other hand, the func\u0000onal implementa\u0000on above is a direct, and crystal clear representa\u0000on of what we wish to compute. Interes\u0000ngly, clarity comes at no expense in terms of eﬃciency: lazy evalua\u0000on, available with Java streams, ensures that the ﬁnal result is computed with just one traversal of the stream. Furthermore, using p a r a l l e l S t r e a m ( ) in place of s t r e a m ( ) would enable a parallel evalua\u0000on scheme in which the Java run\u0000me par\u0000\u0000ons the stream into mul\u0000ple sub-streams and let the aggregate opera\u0000ons process these sub-streams independently of each other by minimizing the synchroniza\u0000ons among the parallel threads. The same would not be possible with the impera\u0000ve implementa\u0000on, as in that case the parallel threads would have to synchronize on the updates to the shared memory loca\u0000on m a x A g e to ensure the correctness of the ﬁnal result. From impera\u0000ve to func\u0000onal style (2/2) Consider the following while loop for prin\u0000ng the elements of an array of strings. d e f p r i n t A r g s ( a r g s : A r r a y [ S t r i n g ] ) : U n i t = v a r i = 0 w h i l e ( i < a r g s . l e n g t h ) p r i n t l n ( a r g s ( i ) ) i + = 1 By no mistake, this is a paradigma\u0000c example of impera\u0000ve style. An equivalent version of the program, exhibi\u0000ng some func\u0000onal ﬂavor is obtained by ge\u0000ng rid of the v a r declara\u0000on, for example, as follows: d e f p r i n t A r g s ( a r g s : A r r a y [ S t r i n g ] ) : U n i t = fo r ( a r g < - a r g s ) p r i n t l n ( a r g ) The refactored code is clearer, more concise, and less error-prone than the original (purely impera\u0000ve) code. S\u0000ll, the refactored p r i n t A r g s is not purely func\u0000onal, because it has side eﬀects —in this case, prin\u0000ng to the standard output stream — as it is signaled by the return type U n i t : if a func\u0000on isn’t returning any interes\u0000ng value, which is what a result type of U n i t means, the only way that func\u0000on can make a diﬀerence in the world is through some kind of side eﬀect. A purely func\u0000onal version of the code would deﬁne a method that formats its arguments to make them ready for prin\u0000ng, and only then proceed with the actual prin\u0000ng, so as to isolate the purely func\u0000onal components from the components with side eﬀects: d e f p r i n t A r g s ( a r g s : A r r a y [ S t r i n g ] ) : U n i t = d e f fo r m a t A r g s ( a r g s : A r r a y [ S t r i n g ] ) : S t r i n g = a r g s . m k S t r i n g ( \" \\ n \" ) p r i n t l n ( fo r m a t A r g s ( a r g s ) The m k S t r i n g method, which is available on collec\u0000ons, returns a string consis\u0000ng of the result of calling t o S t r i n g on each element, separated by the string received as argument. Thus if a r g s contains three elements \" z e r o \" , \" o n e \" , and \" t w o \" , fo r m a t A r g s will return \" z e r o \\ n o n e \\ n t w o \" : this doesn’t actually print anything out, but that is easily accomplished by passing its result to p r i n t l n . The beneﬁts of Func\u0000onal Programming - Referen\u0000al Transparency and Equa\u0000onal Reasoning The beneﬁts of a func\u0000onal programming style (in which side eﬀects are strongly discouraged but not necessarily eliminated) has been advocated in many modern languages: ML and Scheme are the most notable examples. On the other hand, there is a very large cons\u0000tuency of purists in the func\u0000onal programming community who believe that purely func\u0000onal languages are not just suﬃcient for general compu\u0000ng needs but, be\u0000er because of their “purity”, as purity brings with it referen\u0000al transparency. Referen\u0000al transparency (RT) is o\u0000en referred to as the quintessence of pure func\u0000onal programing. It is a property of expressions, not just of func\u0000ons, that we may express as follows: An expression e is referen\u0000ally transparent if for any program p containing e all occurrences of e be replaced by the result of its evalua\u0000on without changing the meaning of p A consequence of this deﬁni\u0000on is that if a variable is bound to a referen\u0000ally transparent expression, replacing each variable occurrence with its referent expression does not change the result of the computa\u0000on Referen\u0000al transparency is interes\u0000ng because it forces the invariant that everything that a func\u0000on does is represented by the value the func\u0000on returns. This invariant also enables a simple and very natural way of reasoning about program evalua\u0000on and behavior known as the subs\u0000tu\u0000on model. When expressions are referen\u0000ally transparent, we can imagine that the computa\u0000on proceeds as when we solve an equa\u0000on, by expanding all variables with the expressions they are bound to and then reduce the expression under considera\u0000on to its simplest form. As we shall see along the course, this is precisely the way we will formalize the no\u0000on of evalua\u0000on in our founda\u0000onal presenta\u0000on of the theory of programming languages. Here, we exemplify the eﬀects of RT, and of lack thereof, with two (Scala) examples. First consider the case of an iden\u0000ﬁer x bound to a string, say a b c . In Scala, strings are immutable, hence any computa\u0000on manipula\u0000ng a string creates a new string leaving the old string unchanged. As a result, an equality test like x . r e v e r s e = = x . r e v e r s e / / t r u e will always succeed, as it will the result of subs\u0000tu\u0000ng x with its referent a b c . \" a b c \" . r e v e r s e = = \" a b c \" . r e v e r s e / / t r u e Now take a new iden\u0000ﬁer y and assume it is ini\u0000alized to the value n e w S t r i n g B u i l d e r ( \" a b c ) \" . S t r i n g B u i l d e r are much like strings, but certain methods operate on them in place: one such method is a p p e n d . Thus, unlike the previous case, the test below fails, in spite of the two expressions looking the exact same: y . a p p e n d ( \" d \" ) = = y . a p p e n d ( \" d \" ) / / fa l s e No\u0000ce that if we replace y with its referent expression the result changes: \" a b c \" . a p p e n d ( \" d \" ) = = y . a p p e n d ( \" d \" ) / / t r u e \" a b c \" . a p p e n d ( \" d \" ) = = \" a b c \" . a p p e n d ( \" d \" ) / / t r u e The beneﬁts of referen\u0000al transparency should already be evident from these examples. Reasoning on RT expressions is simple and direct as the eﬀects of evalua\u0000on are purely local (they aﬀect only the expression being evaluated) and we need not mentally simulate sequences of stated updates to understand a block of code. Evalua\u0000on is simply simulated by subs\u0000tu\u0000on and local rewri\u0000ng. As a result, RT programs are inherently modular, as they consist of component func\u0000ons and expressions that can be understood and reused independently of the context, so that the meaning of their composi\u0000on only depends on their meaning of the components and on the rule governing their composi\u0000on. Remarkably, this kind of modular understanding is also reﬂected at the implementa\u0000on level, enabling independent (i.e. parallel) evalua\u0000on and other very eﬀec\u0000ve op\u0000miza\u0000on techniques. On the other hand, reasoning on the behavior of non RT expressions inevitably requires to take the context and the order of evalua\u0000on into account. This is not to say that a formal seman\u0000cs of impera\u0000ve (or more generally non RT) programs is impossible to achieve (there are, in fact, successful examples of denota\u0000onal or axioma\u0000c seman\u0000c characteriza\u0000ons of such programs), but the direct ﬂavor of equa\u0000onal reasoning is incomparably simpler and more natural. Is studying Func\u0000onal Programming a good idea? As you’ll have most probably realized by now, func\u0000onal programming will play a central role in this course. If you are not yet convinced that studying func\u0000onal languages is a good idea, here are three ﬁnal thoughts for you to consider: Func\u0000onal programming will make you think diﬀerently about programming: Mainstream languages are all about state Func\u0000onal programming is all about values Func\u0000onal programming is “cu\u0000ng edge” A lot of current research is done based on func\u0000onal programming Rise of mul\u0000-core, parallel programming is likely to make minimizing state much more important New ideas help make you a be\u0000er programmer, in any language. CREDITS The iterator example is based on this paper by Silvia Crafa on an evolu\u0000onary view of programming languages abstrac\u0000ons. The sec\u0000on on referen\u0000al transparency is adapted from the ﬁrst chapter of Chiusano & Bjanason’s textbook on Func\u0000onal Programming in Scala. FURTHER READING B. Goldberg: Func\u0000onal Programming Languages. ACM Compu\u0000ng surveys, Vol. 28, No. 1, March 1996. Paul Hudak: Concep\u0000on, Evolu\u0000on, and Applica\u0000on of Func\u0000onal Programming Languages. ACM Compu\u0000ng Surveys, Vol. 14, No. 3, September 1989","libVersion":"0.3.2","langs":""}