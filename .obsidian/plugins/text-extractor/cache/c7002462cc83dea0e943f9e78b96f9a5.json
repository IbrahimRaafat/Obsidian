{"path":"Formal Methods/Lectures/lezione8.pdf","text":"FORMAL METHODS FOR SYSTEM VERIFICATION The Stochastic Model underlying a PEPA component Sabina Rossi DAIS Universit`a Ca’ Foscari Venezia Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION The stochastic process underlying a PEPA component Generating the Markov Process The derivation graph of a PEPA model may be used to generate a Continuous Time Markov Chain. To form the stochastic process: a state is associated to each node of the graph, there is a transition between two states if there is an arc in the graph between the corresponding nodes, the transition rate between two states is the sum of the activity rates labelling arcs connecting the corresponding nodes in the derivation graph. Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION The stochastic process underlying a PEPA component Theorem For any ﬁnite PEPA model P def = P0, if we deﬁne the stochastic process X (t), such that X (t) = Pi indicates that the system behaves as component Pi at time t, then X (t) is a Markov process. Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Deﬁnitions Sojourn time of a component P The sojourn time of a component P is an exponentially distributed random variable, whose parameter is the sum of the activity rates of the activities enabled by P. The mean, or expected, sojourn time will therefore be   ∑ a∈Act(P) ra   −1 Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Deﬁnitions Exit rate from a component P The exit rate from a component P is the rate at which the system leaves the state corresponding to the component P. It is denoted by q(P), and is deﬁned as: q(P) = ∑ a∈Act(P) ra This can be regarded as the rate at which the component P does something, or equivalently, the rate at which it completes an arbitrary activity. Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Deﬁnitions Transition rate The transition rate between two components Pi and Pj is denoted by q(Pi , Pj ). This is the rate at which the system changes from behaving as Pi to behaving as Pj , or the rate at which transitions between the states corresponding to Pi and Pj occur. It is the sum of the activity rates labelling arcs which connect the node corresponding to Pi to the node corresponding to Pj in the derivation graph, i.e., q(Pi , Pj ) = ∑ a∈Act(Pi |Pj ) ra where Act(Pi |Pj ) = {|a ∈ Act(Pi )| Pi a −→ Pj |}. Clearly, if Pj is not a one-step derivative of Pi , q(Pi , Pj ) = 0. Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Deﬁnitions Conditional transition rate The conditional transition rate from Pi to Pj via an action type α is denoted by q(Pi , Pj , α). This is the sum of the activity rates labelling arcs connecting the corresponding nodes in the derivation graph which are also labelled by the action type α. It is the rate at which a system behaving as component Pi evolves to behaving as component Pj as the result of completing a type α activity. Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Deﬁnitions Conditional exit rate The conditional exit rate from a component P, denoted by q(P, α), is the rate of leaving P via an activity of a given action type α. It is the sum of all activity rates for type α activities enabled in P. It is clear that the conditional exit rate of P via α is the same as the apparent rate of α in P, i.e., q(P, α) = rα(P) . Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Deﬁnitions Conditional probabilities The conditional probabilities of a component P ending a sojourn by completing a given activity a, or any activity of a given action type α, are denoted by Pr (P, a) and Pr (P, α), respectively. There are deﬁend by: Pr (P, a) = ra∑ b∈Act(P) rb Pr (P, α) = rα(P) ∑ (β,r )∈Act(P) rβ(P) Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Deﬁnitions Transition probabilities The transition probability that a component Pi completes an activity and then the system behaves as Pj is denoted by Pr (Pi , Pj ). This is deﬁned as: Pr (Pi , Pj ) = q(Pi , Pj ) q(Pi ) Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Deﬁnitions Inﬁnitesimal generator matrix The inﬁnitesimal generator matrix Q of the Markov process underlying a PEPA component P def = P0 is deﬁned as: let ds(P) = {P0, . . . , Pn}, the oﬀ-diagonal elements qij are deﬁned by: qij = q(Pi , Pj ) for all Pi , Pj ∈ ds(P) the diagonal elements are formed as the negative sum of the non-diagonal elements of each row, i.e., qii = −q(Pi ) . Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Deﬁnitions Steady state probability We are interested in analyzing the behaviour of systems over an extended period of time. The system should have settled into some “normal” pattern of behaviour in which the rate of ﬂow out of any state is balanced by the rate of ﬂow into the state. This situation is called steady state or equilibrium. Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Deﬁnitions Steady state probability A steady state probability distribution for the process undelying a PEPA component P, π, if it exists, can be computed by solving the matrix equation πQ = 0 subject to the normalization condition ∑ Pi ∈ds(P) π(Pi ) = 1 Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Deﬁnitions Finite models A PEPA model is ﬁnite if its derivative set contains a ﬁnite number of components. This does not restrict the behaviour of the model to be ﬁnite in the sense of operating for only a ﬁnite time. Instead the process exhibit inﬁnite behaviour over a ﬁnite number of states. Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION PEPA models with equilibrium behaviour Cyclic, or irreducible, PEPA component A PEPA component is cyclic, or irreducible, if it is a derivative of all the components in its derivative set, i.e., P ∈ ds(Pi ) for all i such that Pi ∈ ds(P) A cyclic component is one in which behaviour may always be repeated, i.e., how ever the model evolves from this component it will always eventually return to this component. In particular, this means that for every choice, whichever component is choosen the model must eventually return to the point where the choice can be made again, possibly with a diﬀerent outcome. This implies that choice combinators may only be introduced at the lowest level of a cyclic component. Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION PEPA models with equilibrium behaviour Cyclic, or irreducible, PEPA component A PEPA component which involves a choice combinator may subsequently be used in a cooperation, but a component involving a cooperation may not subsequently used in a chooice. Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION PEPA models with equilibrium behaviour Cyclic, or irreducible, PEPA component Example: consider the component: C def = C1 + C2 where C1 def = P0 \u0003\u0001 L Q0 C2 def = R0 \u0003\u0001 K S0 Whichever component Ci ﬁrst completes an activity, the component will then behave as Ci , C1 say. All derivaties of C1 must have the form C ′ 1 def = Pi \u0003\u0001 L Qj for some Pi ∈ ds(P0) and Qj ∈ ds(Q0). The component C is cyclic only if C1 + C2 ∈ ds(C ). This implies that there is some derivative of C1 which is syntactically equivalent to (P0 \u0003\u0001 L Q0) + (R0 \u0003\u0001 K S0), i.e., some Pi and Qj such that Pi \u0003\u0001 L Qj ≡ (P0 \u0003\u0001 L Q0) + (R0 \u0003\u0001 K S0). However this is not possible and then C cannot be cyclic. Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION PEPA models with equilibrium behaviour Cyclic, or irreducible, PEPA component If a PEPA component is irreducible then all choices must occur within cooperating components. This jiustiﬁes the two-leyer syntax for terms in PEPA: sequential components: S ::= (α, r ).S | S1 + S2 | A cooperating components: C ::= C1 \u0003\u0001 L C2 | C /L | S The Markov process undelying a PEPA component is irreducible if, and only if, the initial component of the model is cyclic. Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION PEPA models with equilibrium behaviour Assumptions We assume that all PEPA models are time homogeneous, ﬁnite and cyclic. If a Markov process that is irreducible has a ﬁnite state space then all its states are positive recurrent. Thus the PEPA models we consider represent systems with steady state behavoiur. Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Derivation of Performance Measures Steady state distribution The steady state distribution of a PEPA component is interpreted as the equilibrium probability (or the long run relative frequency) of the model behaving as each of its derivatives. The probability, when the system has settled into a regular pattern of behaviour, that the system is behaving in the way characterized by some component of the PEPA model Pi , is π(Pi ). We can regard π(Pi ) as the proportion of time that the system will spend behaving as component Pi . Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Derivation of Performance Measures Performance measures Performance measures such as throughput, average delay time and queue lengths can be derived from the steady state distribution. We associate rewards with certain activities within the system. The reward associated with a component, and the corresponding state, is then the sum of the rewards attached to the activities it enables. Performance measures are then derived from the total reward based on the steady state probability distribution. If ρi is the reward associated with component Pi and π is the steady state distribution, then the total reward R is R = ∑ i ρi π(Pi ) Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Example 1: Simple resource usage as two cooperating components Description The system has two components: Process and Resource. The Process will undertake two activities consecutively: use with some rate r1 in cooperation with the resource, and task at some rate r2. The Resource will engage in two activities consecutively: use at some rate r3 and update at a rate r4. Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Example 1: Simple resource usage as two cooperating components PEPA model Process def = (use, r1).Process ′ Process ′ def = (task, r2).Process Resource def = (use, r3).Resource′ Resource′ def = (update, r4).Resource System def = Process \u0003\u0001 {use} Resource Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Example 1: Simple resource usage as two cooperating components Derivation graph Let r13 = min(r1, r2). System Process′ \u0003\u0001 use Resouce′ Process \u0003\u0001 use Resouce′ Process′ \u0003\u0001 use Resouce (use,r13) (task,r2) (update,r4 ) (update,r4) (task,r2 ) Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Example 1: Simple resource usage as two cooperating components The underlying CTMC Let the states of the underlying Markov process be labelled X0, X1, X2, X3, idenﬁed as follows: X0 ↔ Process \u0003\u0001 use Resouce X1 ↔ Process ′ \u0003\u0001 use Resouce′ X2 ↔ Process \u0003\u0001 use Resouce′ X3 ↔ Process ′ \u0003\u0001 use Resouce The inﬁnitesimal generator matrix Q has the following form: Q =        −r13 r13 0 0 −(r2 + r4) r2 r4 r4 0 −r4 0 r2 0 0 −r2        Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Example 1: Simple resource usage as two cooperating components Steady state distribution Solving the global balance equations with the normalization condition πQ = 0 3∑ i=0 π(Xi ) = 1 we obtain: π(X0) = r2r4(r2+r4) (r2+r4)r2r4+r13r2r4+r13r 2 2 +r13r 2 4 π(X1) = r2r4r13 (r2+r4)r2r4+r13r2r4+r13r 2 2 +r13r 2 4 π(X2) = r13r 2 2 (r2+r4)r2r4+r13r2r4+r13r 2 2 +r13r 2 4 π(X3) = r13r 2 4 (r2+r4)r2r4+r13r2r4+r13r 2 2 +r13r 2 4 Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Example 1: Simple resource usage as two cooperating components Steady state distribution Suppose that the activities have the following rates: (use, r1) : r1 = 2 (task, r2) : r2 = 2 (use, r3) : r3 = 6 (update, r4) : r4 = 8 (use, r13) : r13 = min(2, 6) = 2 With these values we obtain π(X0) = 20 41 π(X1) = 4 41 π(X2) = 1 41 π(X3) = 16 41 Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Example 1: Simple resource usage as two cooperating components Performance measures: Utilisation of the resource The resource will be utilised whenever it is engaged in a use activity or an update activity. Therefore to derive the utilisation we associate a reward of 1 with each of these activities. Then, if ρi denotes the reward associated with state Xi , then ρ0 = 1 ρ1 = 1 ρ2 = 1 ρ3 = 0 . The utilisation Ures is the total probability that the model is in one of the states in which the resource is in use, i.e., it is equal to the total reward: Ures = ρ0 π(X0) + ρ1 π(X1) + ρ2 π(X2) = 25 41 = 60.98% Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Example 1: Simple resource usage as two cooperating components Performance measures: Throughput of the process The throughput of the process will be the expected number of completed (use, task) pairs of activities to be completed per unit time. Since each activity is visited only once, this throughput will be the same as the throughput of either of the activities. The throughput Tuse of activity use is found by associating a reward equal to the activity rate with each instance of the activity. Thus, the rewards associated with states are: ρ0 = 2 ρ1 = 0 ρ2 = 0 ρ3 = 0 Tuse = ρ0 × π(X0) = 2 × π(X0) = 40 41 = 0.975 or, since 1/0.975 ∼ 1.025, approximately 1 activity every 1.025 milliseconds. Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Example 2: A faulty component in cooperation with a resource and a repairman Description Consider a system consisting of the following components: Comp, Res and Repman. Comp is a faulty component which is also capable of completing a task satisfactorily. Res is a resource: the faulty component may need to cooperate with a resource in order to complete its task. Repman represents a repairman: the component also needs to cooperate with a repairman in order to be rapaired. the System consists of two components competing for access to the resource and the repairman. Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Example 2: A faulty component in cooperation with a resource and a repairman PEPA model Consider the following PEPA model for System: Comp def = (error , ϵ).(repair , ρ).Comp + (task, µ).Comp Res def = (task, ⊤).(reset, r ).Res Repman def = (repair , ⊤).Repman System def = ((Comp||Comp) \u0003\u0001 {task} Res) \u0003\u0001 {repair } Repman Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Example 2: A faulty component in cooperation with a resource and a repairman Derivation graph Draw the derivation graph of System: S0 def = ((Comp||Comp) \u0003\u0001 {task} Res) \u0003\u0001 {repair } Repman S1 def = ((Comp||Comp) \u0003\u0001 {task} (reset, r ).Res) \u0003\u0001 {repair } Repman S2 def = (((repair , ρ).Comp||Comp) \u0003\u0001 {task} Res) \u0003\u0001 {repair } Repman S3 def = ((Comp||(repair , ρ).Comp) \u0003\u0001 {task} Res) \u0003\u0001 {repair } Repman S4 def = (((repair , ρ).Comp||(repair , ρ).Comp) \u0003\u0001 {task} Res) \u0003\u0001 {repair } Repman S5 def = (((repair , ρ).Comp||Comp) \u0003\u0001 {task} (reset, r ).Res) \u0003\u0001 {repair } Repman S6 def = ((Comp||(repair , ρ).Comp) \u0003\u0001 {task} (reset, r ).Res) \u0003\u0001 {repair } Repman S7 def = (((repair , ρ).Comp||(repair , ρ).Comp) \u0003\u0001 {task} (reset, r ).Res) \u0003\u0001 {repair } Repman Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Example 2: A faulty component in cooperation with a resource and a repairman Derivation graph The derivation graph of System is: S3 S6 S4 S0 S1 S7 S2 S5 (task,µ) (error ,ϵ) (repair ,ρ) (reset,r ) (error ,ϵ) (repair ,ρ) (repair ,ρ) (repair ,ρ) (error ,ϵ) (error ,ϵ) (task,µ) (task,µ) (error ,ϵ) (error ,ϵ) (reset,r ) (repair ,ρ) (repair ,ρ) (reset,r ) (task,µ) (repair ,ρ) (error ,ϵ) (reset,r ) (repair ,ρ) (error ,ϵ) Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Example 2: A faulty component in cooperation with a resource and a repairman The underlying CTMC Note that there is a pair of arcs in the derivation graph between the initial state S0 and its one-step derivative S1. This captures the fact that there are two distinct derivations of the activity (task, µ) according to whether the ﬁrst or second component completes the task in cooperation with the resource. The derivation graph is the basis of the underlying CTMC. Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Example 2: A faulty component in cooperation with a resource and a repairman The underlying CTMC The underlying CTMC is: X3 X6 X4 X0 X1 X7 X2 X5 µ ϵ ρ r ϵ ρ ρ ρ ϵ ϵ 2µ ϵ ϵ r ρ ρ r µ ρ ϵ r ρ ϵ Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Example 2: A faulty component in cooperation with a resource and a repairman The global balance equations of System π0(2µ + 2ϵ) = π1r + π2ρ + π3ρ π1(r + 2ϵ) = π02µ + π5ρ + π6ρ π2(r + µ + ϵ) = π0ϵ + π4ρ + π5r π3(r + µ + ϵ) = π0ϵ + π4ρ + π6r π4(2ρ) = π2ϵ + π3ϵ + π7r π5(r + ρ + ϵ) = π1ϵ + π2µ + π7ρ π6(r + ρ + ϵ) = π1ϵ + π3µ + π7ρ π7(r + 2ρ) = π6ϵ + π7ϵ π0 + π1 + π2 + π3 + π4 + π5 + π6 + π7 = 1 The normalization condition π0 + π1 + π2 + π3 + π4 + π5 + π6 + π7 = 1 Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Example 2: A faulty component in cooperation with a resource and a repairman Performance measures: Utilisation of the resource The utilisation of the resource is the total probability that the model is in one of the states in which the resource is in use: Ures = π0 + π2 + π3 Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION Example 2: A faulty component in cooperation with a resource and a repairman Performance measures: Throughput of task The throughput of task is the expected number of tasks completed per unit time. Ttask = 2µπ0 + µπ2 + µπ3 Sabina Rossi FORMAL METHODS FOR SYSTEM VERIFICATION","libVersion":"0.3.2","langs":""}