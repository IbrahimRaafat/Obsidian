{"path":"Advanced Programming/PDFs/4. Pure λ Calculus - Part II.pdf","text":"ADVANCED PROGRAMMING LANGUAGES Fall 2023, CM 0632. MSc in Computer Science and Informa\u0000on Technology, Ca’ Foscari University of Venice The expressive power of the Lambda Calculus We closed our last lecture men\u0000oning the Church-Turing Thesis about the diﬀerent characteriza\u0000ons of the no\u0000on of computable func\u0000ons. A you (should) know, the thesis has remained without a proof, but the various cross-encodings that proved the equivalent expressive power of lambda-calculus and other models of computa\u0000on has long been considered as a de- facto proof. Instead of discussing such cross-encodings, below we illustrate the power of the Lambda Calculus by showing it at work on the encoding of simple datatypes (booleans and numerals) together with their operators. Church Booleans. We start with Booleans and condi\u0000onal expressions. As we see, and are represented as func\u0000ons that take two arguments and return, respec\u0000vely, the ﬁrst and the second argument. Though these deﬁni\u0000ons may appear surprising at ﬁrst, you can make sense of them by looking at the encoding of the condi\u0000onal and verifying that corresponds to the applica\u0000on of to and , which in turn behaves as the more familiar , expression whenever is either and . Given that and choose the ﬁrst and second argument, they may be combined to achieve the expected behavior of the logical operator, similarly to how they are employed to select the branches of the condi\u0000onal. We look at the deﬁni\u0000ons at work on few examples: true false cond ≡ ≡ ≡ λx.λy.x λx.λy.y λx.λy.λz( x y z) true false cond M N P M N P if M  then N  else P M true false true false and or not ≡ ≡ ≡ λx.λy.x y false λx.λy.x true y λp.p false true Church Numerals. Next we show the encoding of integers by means of the well-known Church numerals. The underlying intui\u0000on is to use the structure of lambda terms to count. Speciﬁcally, each number is represented as a lambda abstrac\u0000on that expects two arguments — a func\u0000on and an argument – and applies the func\u0000on a corresponding number of \u0000mes. Thus, given any func\u0000on and argument , we have: The encoding can therefore be deﬁned as follows: The arithme\u0000c operators can then be represented as func\u0000ons over the Church numerals. Successor. Given any numeral , is the func\u0000on that, given and , applies to n+1 \u0000mes. Now, , so that . Hence: Plus. Given any two numeral and , is the func\u0000on that, given and , applies to m+n \u0000mes. Again, : thus to obtain the result of the addi\u0000on, we must and true false or true false not true ⇒⇒ ⇒⇒ ⇒⇒ ⇒⇒ ⇒⇒ ⇒⇒ true false false false true true false true true false true false f x 0 applies f  to x zero times : 1 applies f  to x one time : 2 applies f  to x two times : 3 applies f  to x two times : …  and so on  … 0 f x = x 1 f x = f x 2 f x = f ( f x) 3 f x = f ( f ( f x) ) … 0 1 2 3 ⋮ n ≡ ≡ ≡ ≡ ≡ λf .λx.x λf .λx.( f x) λf .λx.f ( f x) λf .λx.f ( f ( f x) ) ⋮ λf .λx.( f x) n n succ n f x f x n f x = f x n succ n = λf .λx.f ( n f x) succ = λn.λf .λx.f ( n f x) m n plus m n f x f x n f x = f x n apply m \u0000mes on top of the n \u0000mes accounted for by . But that can be accomplished by the applica\u0000on . Hence Mult. In this case, given and , we must deﬁne a func\u0000on that, given (and ) applies (to ) m n \u0000mes. To see how that can be accomplished, ﬁrst note that, by deﬁni\u0000on, . By -equality, we have and then the desired result may be obtained by m applica\u0000ons of to . Hence: Exercises 1. Prac\u0000ce with the deﬁni\u0000ons. Try and play with the deﬁni\u0000ons of the Church booleans and numerals with their operators to verify that their evalua\u0000on behaves as expected. For instance, check the following: 2. xor. Deﬁne the lambda calculus encoding of the logical operator XOR, which is true only when its two arguments have diﬀerent truth values. 3. isZero. Deﬁne a lambda term to encode the test func\u0000on: given a numeral the func\u0000on returns if is , otherwise it returns 4. Church pairs. In class we looked at a direct encoding of booleans and condi\u0000onals. Here we study a diﬀerent approach that draws on pairs as the main building block. We use the following nota\u0000on: def fun = M to introduce fun as a name for the λ term M M = N to denote that M evaluates to N (with some reduc\u0000on order) Pairs are encoded as the following structured lambda term:   def pair = λ fst. λ snd. λ f. (f fst snd) A pair is a func\u0000on that takes its two components arguments and a func\u0000on which it applies to the components, so that f n f x m f ( f x) = n m f ( n f x) plus = λm.λn.λf .λx.m f ( n f x) m n f x f x ∗ n f = λx.f x n η n f = f n ( n f ) x mult = λm.λn.λf .λx.m ( n f ) x and( not true) ( or false true) = false plus 3 4 = 7 mult 3 2 = 6 … isZero n true n 0 false   pair a b = λ f. (f a b) Now we can introduce the two general selectors:   def select-ﬁrst = λ fst. λ snd. fst   def select-second = λ fst. λ snd. snd From them, we obtain two pair selectors by applying the pair constructor to the general selectors:   def ﬁrst = λ p. (p select-ﬁrst)   def second = λ p. p (select-second) Exercise 4.1. Verify that:   ﬁrst (pair a b) = a   second (pair a b) = b Exercise 4.2. Write a version of pair called fun-pair that takes ﬁve arguments including f,g,x,y and makes a pair with ﬁrst element f(x) and second g(y). 5. More Booleans In class we have deﬁned the boolean operators and, or and not from ﬁrst principles. Here we look at a diﬀerent encoding, which we build star\u0000ng from the encoding of the condi\u0000onal expression. We start with not. Wri\u0000en as a C-like condi\u0000onal, one has: not x = x ? false : true. Thus:     def not = λx. (cond false true x) Using β reduc\u0000on, the expression (not x) can be simpliﬁed to (x false true), which leads us to the simpler deﬁni\u0000on we have seen in class.     not = λx. (x false true) We can repeat the same reasoning with and and or. For the former we observe that and(x,y) = x ? y : false, whence:     def and = λx. λy. (cond y false x) For the la\u0000er from or(x,y) = x ? true : y     def or = λx. λy. (cond true y x) Simplifying we have again the lambda terms discussed in class     and = λx. λy. (x y false)     or = λx. λy. (x true y) Exercise 5.1 Repeat the above encoding of boolean operators with a new operator nand (¬(P ∧Q)). That is: Write a C-like x ? y : z condi\u0000onal expression that implements the Boolean func\u0000on nand. Only use the variables x, y the operator not and the constant false in your condi\u0000onal expression. Convert your expression for nand into a λ-calculus cond expression: it should have two λs, one cond, and however many false, not, x, ys you need. Evaluate and simplify the inner body of this expression (removing cond) to get a more elegant func\u0000on for nand of the form λx. λy. (…) Now apply the simpliﬁed expression for nand to the two arguments (x=false, y=true). Show it evaluates to the correct answer. Since the expression will involve strictly true, false, not, can convert to all true, false. Then remember they are select-ﬁrst, select-second, and you can do the job in one line. No need to expand to λ-level. Exercise 5.2. Show that the following two terms evaluate to the same thing for the Boolean argument pair (x,y) = (true, false).   - (nand x y)   - (or (not x) (not y))","libVersion":"0.3.2","langs":""}