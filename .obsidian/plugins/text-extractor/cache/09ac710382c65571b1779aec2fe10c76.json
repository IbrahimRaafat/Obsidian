{"path":"System Security/Lecture 12 Security-APIs.pdf","text":"Security APIs System Security (CM0625, CM0631) 2024-25 UniversitÃ  Caâ€™ Foscari Venezia Riccardo Focardi www.unive.it/data/persone/5590470 secgroup.dais.unive.it Security APIs 2 Hardware Security Modules (HSM) â— Used in the ATM Bank network â— Tamper resistant â— Offer APIs for: â—‹ Managing cryptographic keys â—‹ Decrypting/re-encrypting the PIN â—‹ Checking the validity of the PIN Case study 1: PIN veriï¬cation Photo by Prasun.srivastava - Own work, CC BY-SA 4.0, https://commons.wikimedia.org/w/index.php?curid=34812934 3 PIN veriï¬cation infrastructure (old protocol) 4 PIN veriï¬cation Encrypted PIN Block : contains the PIN at the ATM PIN_V( EPB , vdata,len,dectab,offset ) Data for computing the user PIN Example: PIN_V( {4104,r} k, vdata, 4, 0123456789012345, 4732 ) 1. deck({4104,r} k) = 4104,r 4104 2. encpdk(vdata) = A47295FDE32A48B1 0472 âŠ• 4732 mod 10 = 4104 3. The two values coincide: PIN_V returns â€˜trueâ€™ 5 PIN V(EPB, vdata, len, dectab, offset) { x1 := dec(k,EPB); // decrypt the typed PIN t_pin:=fcheck(x1); // check format, remove random if (t_pin =âŠ¥) then return(â€²â€²format wrongâ€²â€²); x2 :=encpdk(vdata); // encrypt vdata x3 :=left(len,x2); // take left 4-5 hex digits x4 :=decimalize(dectab,x3); // decimalize digits u_pin := sum_mod10(x4, offset); // sum offset if (t_pin == u_pin) then return(â€²â€²PIN is correctâ€²â€²); } PIN veriï¬cation pseudo-code 6 Decimalization attack [Bond, Zielinski â€™03] Example: PIN_V( {4104,r} k, vdata, 4, 0123456789012345, 4732 ) 1. deck({4104,r} k) = 4104,r 4104 2. encpdk(vdata) = A47295FDE32A48B1 0472 âŠ• 4732 mod 10 = 4104 3. PIN_V returns â€˜trueâ€™ 7 Decimalization attack [Bond, Zielinski â€™03] Example: PIN_V( {4104,r} k, vdata, 4, 0 123456789 0 12345, 4732 ) 1. deck({4104,r} k) = 4104,r 4104 2. encpdk(vdata) = A47295FDE32A48B1 0472 âŠ• 4732 mod 10 = 4104 3. PIN_V returns â€˜trueâ€™ 1. Change one digit of dectab 8 Decimalization attack [Bond, Zielinski â€™03] Example: PIN_V( {4104,r} k, vdata, 4, 1 123456789 1 12345, 4732 ) 1. deck({4104,r} k) = 4104,r 4104 2. encpdk(vdata) = A47295FDE32A48B1 0472 âŠ• 4732 mod 10 = 4104 3. PIN_V returns â€˜trueâ€™ 1. Change one digit of dectab 9 Decimalization attack [Bond, Zielinski â€™03] Example: PIN_V( {4104,r} k, vdata, 4, 1 123456789 1 12345, 4732 ) 1. deck({4104,r} k) = 4104,r 4104 2. encpdk(vdata) = A47295FDE32A48B1 0 472 âŠ• 4732 mod 10 = 4104 3. PIN_V returns â€˜trueâ€™ 1. Change one digit of dectab 2. This propagates ... 10 Decimalization attack [Bond, Zielinski â€™03] Example: PIN_V( {4104,r} k, vdata, 4, 1 123456789 1 12345, 4732 ) 1. deck({4104,r} k) = 4104,r 4104 2. encpdk(vdata) = A47295FDE32A48B1 1 472 âŠ• 4732 mod 10 = 4104 3. PIN_V returns â€˜trueâ€™ 1. Change one digit of dectab 2. This propagates ... 11 Decimalization attack [Bond, Zielinski â€™03] Example: PIN_V( {4104,r} k, vdata, 4, 1 123456789 1 12345, 4732 ) 1. deck({4104,r} k) = 4104,r 4104 2. encpdk(vdata) = A47295FDE32A48B1 1 472 âŠ• 4732 mod 10 = 4 104 3. PIN_V returns â€˜trueâ€™ 1. Change one digit of dectab 2. This propagates ... 12 Decimalization attack [Bond, Zielinski â€™03] Example: PIN_V( {4104,r} k, vdata, 4, 1 123456789 1 12345, 4732 ) 1. deck({4104,r} k) = 4104,r 4104 2. encpdk(vdata) = A47295FDE32A48B1 1 472 âŠ• 4732 mod 10 = 5 104 3. PIN_V returns â€˜trueâ€™ 1. Change one digit of dectab 2. This propagates ... 13 Decimalization attack [Bond, Zielinski â€™03] Example: PIN_V( {4104,r} k, vdata, 4, 1 123456789 1 12345, 4732 ) 1. deck({4104,r} k) = 4104,r 4104 2. encpdk(vdata) = A47295FDE32A48B1 1 472 âŠ• 4732 mod 10 = 5 104 3. PIN_V returns â€˜trueâ€™ 1. Change one digit of dectab 2. This propagates ... 14 Decimalization attack [Bond, Zielinski â€™03] Example: PIN_V( {4104,r} k, vdata, 4, 1 123456789 1 12345, 4732 ) 1. deck({4104,r} k) = 4104,r 4104 2. encpdk(vdata) = A47295FDE32A48B1 1 472 âŠ• 4732 mod 10 = 5 104 3. PIN_V returns â€˜falseâ€™ 1. Change one digit of dectab 2. This propagates â€¦ 3. â€¦ and eventually changes the result! 15 Decimalization attack [Bond, Zielinski â€™03] Example: PIN_V( {4104,r} k, vdata, 4, 1 123456789 1 12345, 4732 ) 1. deck({4104,r} k) = 4104,r 4104 2. encpdk(vdata) = A47295FDE32A48B1 1 472 âŠ• 4732 mod 10 = 5 104 3. PIN_V returns â€˜falseâ€™ 1. Change one digit of dectab 2. This propagates â€¦ 3. â€¦ and eventually changes the result! â‡’ We know that 0 appeared in the PIN computation 16 Decimalization attack [Bond, Zielinski â€™03] Example: PIN_V( {4104,r} k, vdata, 4, 1 123456789 1 12345, 4 732 ) 1. deck({4104,r} k) = 4104,r 4104 2. encpdk(vdata) = A47295FDE32A48B1 1 472 âŠ• 4732 mod 10 = 5 104 3. PIN_V returns â€˜falseâ€™ 1. Change one digit of dectab 2. This propagates â€¦ 3. â€¦ and eventually changes the result! â‡’ We know that 0 appeared in the PIN computation 1. We â€œcompensateâ€ on the offset to ï¬nd the position 17 Decimalization attack [Bond, Zielinski â€™03] Example: PIN_V( {4104,r} k, vdata, 4, 1 123456789 1 12345, 3 732 ) 1. deck({4104,r} k) = 4104,r 4104 2. encpdk(vdata) = A47295FDE32A48B1 1 472 âŠ• 4732 mod 10 = 5 104 3. PIN_V returns â€˜falseâ€™ 1. Change one digit of dectab 2. This propagates â€¦ 3. â€¦ and eventually changes the result! â‡’ We know that 0 appeared in the PIN computation 1. We â€œcompensateâ€ on the offset to ï¬nd the position 18 Decimalization attack [Bond, Zielinski â€™03] Example: PIN_V( {4104,r} k, vdata, 4, 1 123456789 1 12345, 3 732 ) 1. deck({4104,r} k) = 4104,r 4104 2. encpdk(vdata) = A47295FDE32A48B1 1 472 âŠ• 4 732 mod 10 = 5 104 3. PIN_V returns â€˜falseâ€™ 1. Change one digit of dectab 2. This propagates â€¦ 3. â€¦ and eventually changes the result! â‡’ We know that 0 appeared in the PIN computation 1. We â€œcompensateâ€ on the offset to ï¬nd the position 19 Decimalization attack [Bond, Zielinski â€™03] Example: PIN_V( {4104,r} k, vdata, 4, 1 123456789 1 12345, 3 732 ) 1. deck({4104,r} k) = 4104,r 4104 2. encpdk(vdata) = A47295FDE32A48B1 1 472 âŠ• 3 732 mod 10 = 5 104 3. PIN_V returns â€˜falseâ€™ 1. Change one digit of dectab 2. This propagates â€¦ 3. â€¦ and eventually changes the result! â‡’ We know that 0 appeared in the PIN computation 1. We â€œcompensateâ€ on the offset to ï¬nd the position 20 Decimalization attack [Bond, Zielinski â€™03] Example: PIN_V( {4104,r} k, vdata, 4, 1 123456789 1 12345, 3 732 ) 1. deck({4104,r} k) = 4104,r 4104 2. encpdk(vdata) = A47295FDE32A48B1 1 472 âŠ• 3 732 mod 10 = 5 104 3. PIN_V returns â€˜falseâ€™ 1. Change one digit of dectab 2. This propagates â€¦ 3. â€¦ and eventually changes the result! â‡’ We know that 0 appeared in the PIN computation 1. We â€œcompensateâ€ on the offset to ï¬nd the position 21 Decimalization attack [Bond, Zielinski â€™03] Example: PIN_V( {4104,r} k, vdata, 4, 1 123456789 1 12345, 3 732 ) 1. deck({4104,r} k) = 4104,r 4104 2. encpdk(vdata) = A47295FDE32A48B1 1 472 âŠ• 3 732 mod 10 = 4 104 3. PIN_V returns â€˜falseâ€™ 1. Change one digit of dectab 2. This propagates â€¦ 3. â€¦ and eventually changes the result! â‡’ We know that 0 appeared in the PIN computation 1. We â€œcompensateâ€ on the offset to ï¬nd the position 2. â€¦ and we see if this ï¬xes the result! 22 Decimalization attack [Bond, Zielinski â€™03] Example: PIN_V( {4104,r} k, vdata, 4, 1 123456789 1 12345, 3 732 ) 1. deck({4104,r} k) = 4104,r 4104 2. encpdk(vdata) = A47295FDE32A48B1 1 472 âŠ• 3 732 mod 10 = 4 104 3. PIN_V returns â€˜trueâ€™ 1. Change one digit of dectab 2. This propagates â€¦ 3. â€¦ and eventually changes the result! â‡’ We know that 0 appeared in the PIN computation 1. We â€œcompensateâ€ on the offset to ï¬nd the position 2. â€¦ and we see if this ï¬xes the result! â‡’ If so we discover value and position! 23 This attack has been shown on real devices â— An insider sniffs ATM card data, launches the attack and infers the PIN â— How many invocations on average? â—‹ Four digit PINs: 14.47 â—‹ Five digit PINs: 19.3 â—‹ Strategies found automatically in [Focardi, Luccio â€™10] â— Once the PIN is found (old) cards can be cloned â‡’ Thousand of PINs leaked in a lunch break! NOTE: in countries where the chip cards are not yet widely used the attack would still work Decimalization attack [Bond, Zielinski â€™03] 24 Case study 2: PKCS#11 25 PKCS#11 is a standard API to cryptographic devices Keys have attributes and are referenced via handles (that we represent with colors) Example: orange key is sensitive and can be used to encrypt/decrypt data PKCS#11 cryptographic operations 26 Security of keys Conï¬dentiality of sensitive keys â— sensitive keys should never be accessible as plaintext outside the device â— all crypto operations happen inside the device Attack scenario 1. the device is used on compromised host 2. the attacker extracts sensitive keys 3. the attacker clones the device 27 Key management example 28 The wrap-and-decrypt attack [CHESâ€™03] 29 Formal veriï¬cation 30 Real attacks [ACM CCSâ€™10] PKCS#11 is still ï¬‚awed after 20+ years !?! 31 Fixes? Fixes: Various proposals in the literature to modify the API, but never included in PKCS#11 â‡’ Proprietary ï¬xes exist but break compliance Example: oï¬„ine key management and no key wrapping in production Mitigations: monitor/ï¬lter API calls locally wrap_with_trusted attribute requires that keys are only wrapped under trusted keys (ï¬‚agged by the Security Oï¬ƒcer) ðŸ‘ Secure key wrapping, in principle âš  No guidance in the docs âš  How should trusted keys be generated/managed? âš  What if a trusted key is ï¬‚agged wrap+decrypt? 32 A new scenario: cloud HSMs HSM hardware accessible as a service in the cloud â— Compliance to standard APIs: no proprietary ï¬xes â— No oï¬„ine, secure key management procedures â— No API-level monitors/ï¬lters New attacker model: a vulnerability in one application would expose the full (ï¬‚awed!) PKCS#11 API PKCS#11 33 A formally veriï¬ed conï¬guration â— User roles to secure PKCS#11 â— First secure PKCS#11 conï¬guration that does not break the API compliance â— Implementation in a real Cloud HSM solution â— Formal model and automated proof of security Focardi & Luccio ACM CCSâ€™21 34 User roles Normal Users (NU): used in production applications, full API but no attack should be possible Key Managers (KM): create and manage candidate trusted keys Security Oï¬ƒcer (SO): admin, cannot do crypto but marks trusted keys â— KMs and SO only accessed by management apps or humans Full crypto API NU1 â€¦ NUk Admin API SO Trusted usersKM1 â€¦ KMj 35 Key sharing 1. KMs generate (candidate) trusted wrapping keys 2. KMs share these keys with NUs 3. NUs can use wrapping keys but cannot modify their attributes, e.g., cannot mark them as decrypt keys â— Key sharing is not in PKCS#11 but can be added on top, at the cloud/admin layer KM NU trusted: owned by KM and shared with NU NU can use the key but cannot modify its attributes 36 Secure conï¬guration Rule 1 (Sensitive keys) . Sensitive keys should be generated with wrap_with_trusted set or extractable unset (i.e. will never be wrapped). Rule 2 (Trusted keys) . The SO sets the trusted attribute only on candidate keys generated by one of the KMs. Rule 3 (Roles of candidate keys) . Candidate keys managed by the KMs should only admit wrap and unwrap operations, during their lifetime. Rule 4 (Management of candidate keys) . Candidate keys managed by the KMs should be generated with extractable unset (i.e. will never be wrapped) Rule 5 (Freshness of candidate keys) . Candidate keys managed by the KMs should be freshly generated in the device. 37 AWS CloudHSM implements the required key sharing capability: â€œUsers who share the key can use the key in cryptographic operations, but they cannot change its attributesâ€ â— The secure conï¬guration can be implemented straightforwardly Note: we assume a worst-case scenario in which all keys are shared Implementation in real cloud HSMs Other cloud solutions: â— do not have publicly available documentation (e.g. Utimaco, Microsoft) â— do not implement PKCS#11, yet? (e.g. Google) â— do not seem to implement key sharing in the form we need (e.g. IBM) 38 Formal analysis We formalize a signiï¬cant subset of PKCS#11 in the Tamarin prover: â— Symmetric crypto and wrap â— wrap_with_trusted and trusted attributes â— User roles + key sharing We automatically prove security for an unbounded number of users, keys and sessions rule Wrap: [ !NU(U), !Key(U1,ha1,k1), !Key(U2,ha2,k2) ] --[ Wrap(U,ha1,ha2), IsSet(ha1,'wrap_with_trusted'), IsSet(ha1,'extractable'), IsSet(ha2,'trusted'), IsSet(ha2,'wrap') ]-> [ Out(senc(k1,k2)) ] Normal User U U wraps ha1 with ha2, i.e., k1 with k2 Appropriate attributes ciphertext is sent out (simplified, see the paper for detail!) Keys k1, k2 owned by U1, U2 (ha1, ha2 are handles) 39 Automated proof Keys which, at some point, are marked as trusted are never leaked lemma SecrecyTrusted: \" All W ha k #i #j #w. IsHandle(ha,k)@i & SetAttr(W,ha,'trusted')@j & KU(k)@w ==> F \" Similar lemmas for sensitive keys generated with wrap_with_trusted set or extractable unset (cf. Rule 1) Complete model with additional helper and sanity lemmas available at github.com/secgroup/CloudHSM-model The complete model can be proved automatically in about 1m30s on a MacBook Pro 2018 ha is a handle for key k at time i and ha has trusted set at time j and the attacker knows k at time w implies false, i.e., it cannot occur 40","libVersion":"0.3.2","langs":""}