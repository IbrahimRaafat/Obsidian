{"path":"Advanced Programming/PDFs/8. Algebraic Data Types.pdf","text":"ADVANCED PROGRAMMING LANGUAGES Fall 2024, CM 0632. MSc in Computer Science and Informa\u0000on Technology, Ca’ Foscari University of Venice Algebraic Data Types With the development of the last few lectures, we have most of our language fundamentals in place: func\u0000ons, primi\u0000ve types, their reduc\u0000on rules and a sound type system. Now it’s \u0000me to look at compound types, to account for richer representa\u0000ons of data structures such as those available in prac\u0000cal programming languages. We start with tuples, records and variants, conven\u0000onally referred to as algebraic data types – ADTs. The two fundamental mechanisms that support datatypes are constructors and selectors: a datatype constructor creates the values of the datatype by assembling mul\u0000ple components; datatype selector extracts the components assembled in the datatype. As we will discuss shortly, algebraic refers to the constructors employer to assemble their components, which are are qualiﬁed as algebraic as they are reminiscent of the product and sum operators found in algebra. Datatype Constructors Constructors are the fundamental mechanism to build datatypes: they are best understood as func\u0000ons that inject values from one or more domain (type) into the domain of the datatype being deﬁned. Tuples, records and variants are all created by corresponding constructors. We look at each of them below. Tuples Tuples are the familiar structures we are used to see in mathema\u0000cs. In formal systems as well as in programming languages, they are introduced as structural types which, for each ,n ∈ 0, 1, 2, … are built by the -ary constructor that collects the components (of the respec\u0000ve types) and injects then in a new compound value structured as an - tuple. Thus we have: It does not take long to realize that for each , we must either presuppose that a type-indexed family of constructors exists which includes a speciﬁc constructor for each of the inﬁnitely many possible combina\u0000on of the component types, or else assume that for each there exists a single, polymorphic -ary constructor that may be applied to any combina\u0000on of the component types. In either case, the typing rela\u0000on may be formalized by the following rule: Alterna\u0000vely, we may take -tuples as being built as the composi\u0000on of mul\u0000ple applica\u0000ons of a (type indexed, or polymorphic) constructor for pairs. For instance, the triple type may be constructed as the type or else as the type : in any case, the three types are diﬀerent and, as we discuss shortly, the diﬀerent ways they are constructed, aﬀects the way we deﬁne the selector operators, to access the tuple components. Records Records are a generaliza\u0000on of tuples, in which each component (ﬁeld) is associated with a label drawn from a predeﬁned set (in programming languages are simply iden\u0000ﬁers). Formally, given and a set of dis\u0000nct labels , a record is built by a constructor , which collects the components (of the respec\u0000ve types) and associates them with the corresponding labels within the record. As for tuples, we must presuppose that the record constructors are either type indexed, or polymorphic. In either case, the typing rule has the following general format: n (⋅) :n T ×1 ⋯ × T →n (T 1, … , T )n n n (true, false) : (B ool, B ool) (\"aaa\", true) : (String, B ool) (1, 5, 2, 10) : (Int, Int, Int, Int) (3, true, 2.3, \"aaa\") : (Int, B ool, Double, String) (\"bb\", λ(x : B ool).x ∥ true, ) : (String, B ool → B ool) n n n  (T-Tuple) Γ ⊢ (M , … , M ) : (T , … , T )1 n 1 n Γ ⊢ M : T ⋯ Γ ⊢ M : T 1 1 n n n (T , T , T )1 2 3 ((T , T ), T )1 2 3 (T , (T , T ))1 2 3 L n ℓ , … , ℓ 1 n {ℓ , ⋯ , ℓ } :1 n T ×1 ⋯ × T →n {ℓ :1 T , ⋯ , ℓ :1 n T }n n  (T-Rec) Γ ⊢ {ℓ = M , … , ℓ = M ) : {ℓ : T , … , ℓ : T }1 1 n n 1 1 n n Γ ⊢ M : T ⋯ Γ ⊢ M : T 1 1 n n Given that components are iden\u0000ﬁed by their labels, and the labels are all dis\u0000nct, their order is irrelevant: as a result, records and record types that are equal up to the reordering of their ﬁelds are equated. Before proceeding with a detailed discussion on datatypes, we take a short pause to to examine one fundamental stylis\u0000c diﬀerence between two diﬀerent approaches to introducing such datatypes. This diﬀerence concerns the status of type names. Variants In many situa\u0000ons we deal with compound structures that may have diﬀerent, alterna\u0000ve shapes. For example: a node in a binary tree can be either a leaf or an interior node with two children; a list cell can be either nil or a cons cell carrying a head and a tail; a node of an abstract syntax tree in a compiler can represent a variable, an abstrac\u0000on, an applica\u0000on, etc. The founda\u0000onal mechanisms that support this kind of programming are variants and variant types. We illustrate the idea with a simple example. Suppose we want to deﬁne a new type of shapes, where a shape can be either a circle or a rectangle. We introduce the new type with the structural deﬁni\u0000on below: Here is just an alias for the new variant type expression : the type expression, in turn, introduces a new domain as the disjoint union of two subdomains built by the two data constructors and . When it comes to typing, the purely structural presenta\u0000on of variant types we adopted above poses the problem of associa\u0000ng the elements of the diﬀerent subdomain to the correct variant. Unlike records and tuples, whose structure is en\u0000rely determined by they syntac\u0000c form, each cons\u0000tuent of a variant only accounts for one of the subdomains and provides no informa\u0000on on the other subdomains. In other words, each subdomain can be thought of as part of diﬀerent, possibly unrelated variants. To see the problem, simply consider that in a purely structural se\u0000ng, the following all look like perfectly valid judgements: Shape = ⟨ Circ(Double) ∣ Rect(Double, Double) ⟩ Shape ⟨ Circ(Double) ∣ Rect(Double, Double) ⟩ Circ Rect In a system with subtyping, this could be acceptable, as we could reasonably assume that variant types are ordered, and take as the minimal type for . But without subtyping, all the above types are unrelated and the fact that the judgements are all equally reasonable leaves us no way to elect a unique (or at least preferred) type. To recover type uniqueness, we resort to a mechanism known as type ascrip\u0000on, a syntac\u0000c device that annotates variants values with the intended variant type to drive type checking. As a result, variant values must always carry a type tag, e.g. as in , and the structural typing rule for variant types may then be deﬁned as follows: Nominal presenta\u0000ons, such as the ones we will look at in our next lecture , solve the problem without any need for annota\u0000ons, as they can count on the type declara\u0000ons to associate the datatype values with the correct variant. Pa\u0000ern Matching — A uniform selec\u0000on mechanism We’ve already seen pa\u0000ern-matching at work in a few speciﬁc cases in our overview of Scala. Now, we present it for what it really is, that is a fully general mechanism for selec\u0000ng datatype components. Fundamentally, pa\u0000ern-matching is a mechanism for taking apart a value by ﬁnding out which constructor it was built with and which components the constructor was applied to. Based on that, it provides a uniform (in some cases the only) way to select the cons\u0000tuents of a compound datatype. Pa\u0000erns Given a datatype constructor, a pa\u0000ern is essen\u0000ally a semi-constructed term (value), in which the structure of some of the components are le\u0000 unspeciﬁed and represented by variables. Formally, we represent pa\u0000erns with the nota\u0000on indica\u0000ng a term some of whose sub- terms are the variables : the pa\u0000ern is meant to represent all the terms Circ(3.0) Circ(3.0) Circ(3.0) Circ(3.0) : : : : ⟨ Circ(Double) ⟩ ⟨ Circ(Double) ∣ Rect(Double, Double) ⟩ ⟨ Circ(Double) ∣ Square(Double) ⟩ ⟨ Circ(Double) ∣  … ⟩ ⟨ Circ(Double) ⟩ Circ(3.0) Circ(3.0)@ ⟨Circ(Double) ∣ Square(Double)⟩  (T-Variant) Γ ⊢ C (M )@ ⟨C (T ) ∣ … ∣ C (T )⟩ : ⟨C (T ) ∣ … ∣ C (T )⟩j 1 1 n n 1 1 n n Γ ⊢ M : T (j ∈ 1..n)j P [x , … , x ]1 n P x , … , x 1 n that result from subs\u0000tu\u0000ng the pa\u0000ern variables with proper terms . This leads rather directly to a general deﬁni\u0000on of pa\u0000ern matching: we say that a term matches a pa\u0000ern , if there exist terms such that . We dis\u0000nguish two main kinds of pa\u0000erns. Variable Pa\u0000erns. A variable is a special case of pa\u0000ern that represents (hence is matched by) all terms. Variable pa\u0000erns may also be structured as wildcard pa\u0000erns using the anonymous variable (the wildcard) “ ”. As we will see shortly, using wildcards in place of variables aﬀects the seman\u0000cs of matching expressions Constructor Pa\u0000erns. Given any constructor, any semi-constructed term built with the constructor is a pa\u0000ern. Examples: is a 5-tuple pa\u0000ern, matched by any 5-tuple that has and in the ﬁrst and third posi\u0000on respec\u0000vely. No\u0000ce that wildcards and variables may coexist within a pa\u0000ern. is a 4-tuple (nested) pa\u0000ern, matched by any quadruple whose ﬁrst, third and fourth element are , and a pair whose second element is respec\u0000vely; is a record pa\u0000ern, matched by all pairs whose ﬁeld is the integer is a pa\u0000ern matched by all lists with at least three elements, whose ﬁrst and third elements are the integers and . Exis\u0000ng programming languages provide further pa\u0000ern forms, which we will discuss in the context of Scala in the next lecture. Here, we move on to complete the discussion on pa\u0000ern matching by introducing matching expressions. Matching expressions The formal device for pu\u0000ng pa\u0000erns and composite datatype at work is a special-purpose expression which we refer to as matching expressions. Diﬀerent programming languages employ diﬀerent syntax and naming for such expressions, but the fundamental mechanism is the same: a term is matched against a pa\u0000ern and if the match is successful, a new binding is created for the rest of the computa\u0000on between each variable in and the corresponding sub- term in . The general form of a matching expression is as follows: P [M , … , M ]1 n M , … , M 1 n M P [x , … , x ]1 n N , … , N 1 m M ≡ P [N , … , N ]1 m x _ (false, x, 1, _, z) false 1 (false, x, 1, (y, 3)) false 1 3 {fst = 5, snd = x} fst 5 Cons(5, Cons(x, Cons(3, xs))) IntList 5 3 M P [x , … , x ]1 n P M The variables occurring in each pa\u0000ern may occur free in the corresponding terms to the right for the arrow. In Then, when the expression is evaluated: the term is matched against each of the pa\u0000erns , , . . . if a matching pa\u0000ern is found, then for suitable terms then the evalua\u0000on proceeds with the term obtained from by subs\u0000tu\u0000ng all the free occurrences of the pa\u0000ern variables with the corresponding subterms found in . The following reduc\u0000on formalizes this behavior. For brevity, we present the simpler case in which pa\u0000erns have all just one variable. The generaliza\u0000on to pa\u0000erns with mul\u0000ple variables is straigh\u0000orward. If no pa\u0000ern is found that matches the term being tested, the whole matching expression is stuck. No\u0000ce, however, that in principle the term could match more than one pa\u0000ern, resul\u0000ng in diﬀerent possible reduc\u0000ons for the matching expressions. Since this would clearly break one of the fundamental proper\u0000es of reduc\u0000on (the ﬁrst Church-Rosser theorem) founda\u0000onal calculi require that the pa\u0000erns occurring in a matching expressions be disjoint, so that the term being tested matches at most one pa\u0000ern. Programming languages, instead, take a more pragma\u0000c approach in which (i) the pa\u0000erns are considered for matching sequen\u0000ally, following the order in which they occur in the matching expression, and (ii) only the ﬁrst matching clause is selected for reduc\u0000on. If no pa\u0000ern is found, the expression returns an error: this situa\u0000on is ruled out in prac\u0000ce, as checking that the pa\u0000erns cover the term can easily be accomplished with a sta\u0000c check if the type of the term to be tested is known. The typing rule for matching expressions is so deﬁned as to ensure that types are preserved by the reduc\u0000on. Again, in the interest of brevity, we present the rule for the case of single variable pa\u0000erns: We conclude the discussion on pa\u0000ern matching with two simple Scala examples that manipulate the variant datatypes introduced earlier. d e f a r e a ( s : S h a p e ) = s m a t c h c a s e C i r c l e ( r ) = > M a t h . p o w ( r , 2 ) * M a t h . P I c a s e R e c t a n g l e ( b , h ) = > b * h  M  match P [x , … , x ]⇒1 1,1 1,k1 M  ∣  ⋯  ∣ P [x , … , x ]⇒1 n n,1 n,kn M n M P 1 P 2 P n P i M ≡ P [N , … , N ]i i,1 i,ki N , … , N i,1 i,ki M i M P [N ] match (P [x ]⇒i i 1 1 M  ∣ ⋯ ∣ P [x ]⇒1 n n M )  ⇒  n [N /x ]M i i i  (T-Match) Γ ⊢ M  match (P [x ]⇒ M  ∣  ⋯  ∣ P [x ]⇒ M ) : T1 1 1 n n n Γ ⊢ M : T Γ, x : T ⊢ (P , M ) : (T , T ) ⋯ Γ, x : T ⊢ (P , M ) : (T , T )1 1 1 1 n n n n d e f l e n ( a s : I n t L i s t ) : I n t = a s m a t c h c a s e E m p t y = > 0 c a s e C o n s ( a , a s ) = > 1 + l e n g t h ( a s ) The func\u0000on a r e a takes as a parameter the type S h a p e and it uses pa\u0000ern matching to ﬁgure out whether it’s a C i r c l e or a R e c t a n g l e ) to compute the area accordingly. The l e n func\u0000on operates similarly on type I n t L i s t to compute the list length. Datatype-speciﬁc selectors Though pa\u0000ern matching provides a uniform, fully general scheme for selec\u0000ng the cons\u0000tuents of compound datatypes, tuples and records come equipped with speciﬁc selectors in most popular programming languages. In Scala and various dialects of ML, for instance, the tuple components can be accessed by the posi\u0000onal selectors _ n we have illustrated in our brief overview of Scala. Haskell is an excep\u0000on in that it only provides the and selectors for pairs, and pa\u0000ern matching for general tuples. As for records, most languages, including Scala, adopt the familiar dot nota\u0000on to extract the values associated with the record ﬁelds. Haskell is again the excep\u0000on: given a record with ﬁelds , each label is construed as func\u0000on whose domain is the record type and the codomain is the type . Thus, given the type: d a t a A d d r e s s = A d d r { c i t y : : S t r i n g , s t r e e t : : S t r i n g , n u m b e r : : I n t } Haskell generates three func\u0000ons: c i t y : : A d d r e s s = > S t r i n g s t r e e t : : A d d r e s s = > S t r i n g n u m b e r : : A d d r e s s = > I n t Then given the record a = A d d r { c i t y = \" B o s t o n \" , s t r e e t = \" W o r c e s t e r \" , n u m b e r = 1 5 } , the ﬁelds are accessed by the func\u0000on applica\u0000ons c i t y a , s t r e e t a and n u m b e r a . Exercises 1. Reduc\u0000on and typing for datatype-speciﬁc selectors. Assume we extend our founda\u0000onal presenta\u0000on of datatypes with syntac\u0000c forms to express speciﬁc operators for selec\u0000ng the components of tuples and records. fst snd ℓ :i T i ℓ i T i Deﬁne the reduc\u0000on and typing rules to capture the intended seman\u0000cs and typing rela\u0000on for the new syntac\u0000c forms. 2. Op\u0000on types. One very useful idiom involving variant types is op\u0000onal values. For example, an element of the type is either the trivial value or else natural number wrapped inside the constructor . Deﬁne the Scala implementa\u0000on of the type . 3. Compu\u0000ng with Op\u0000ons. Based on the datatype deﬁni\u0000on of the previous exercise, deﬁne a Scala func\u0000on that operates as the conserva\u0000ve extension of the successor func\u0000on to the type . As further use of op\u0000onal values, consider the following type represen\u0000ng represents ﬁnite mappings from numbers to numbers The domain of such a mapping is the set of inputs for which the result is . Deﬁne the Scala implementa\u0000on of the type and of the following two func\u0000ons: represen\u0000ng the map with empty domain that, given a ﬁnite map and and two natural numbers , returns a new map which extends (or modiﬁes) with an entry mapping the to CREDITS The discussion on new types and data types in the lambda calculus is adapted from Chapter 11 of Prof. Benjamin’s Pierce’s book on Types and Programming Languages. MIT Press. 2001. The sec\u0000on of nominal vs structural typing is taken from Chapter 19.3 of the same book. M   ::=   ⋯  ∣ M ._j ∣ M .ℓ  ∣  ⋯j OptionNat = ⟨NaN ∣ Some(Nat)⟩ NaN Some OptionNat succ : OptionNat → OptionNat OptionNat FiniteMap = Nat → OptionNat Some(n) FiniteMap emptyMap : FiniteMap extendMap : FiniteMap → Nat → Nat → FiniteMap M n, v M n v","libVersion":"0.3.2","langs":""}